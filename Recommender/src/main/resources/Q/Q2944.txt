 question  ,  "synchronized(sobject)  {mshouldexit  =  true;  sobject.notifyall()while  (!mexited)  {try  {  sobject.wait();}  catch  (interruptedexception  ex)  {  thread.currentthread().interrupt();}  }};  mshouldexit;  sobject;  sobject.wait();  sobject.wait();  sobject;  interrupt();  glsurfaceview.glthread.surfacecreated();public  void  surfacecreated()  {synchronized(sglthreadmanager)  {if  (log_threads)  {log.i(""glthread""'  '  ""surfacecreated  tid=""  +  getid());}mhassurface  =  true;sglthreadmanager.notifyall();while((mwaitingforsurface)  &&  (!mexited))  {try  {sglthreadmanager.wait();}  catch  (interruptedexception  e)  {thread.currentthread().interrupt();}}}};  setrenderer(...);  visibility.visible;  interruptedexception;  wait();  mwaitingforsurface"  ,ive  come  across  the  code  below  and  im  wonder  if  it  doe  exact  what  i  think  it  doe  about  the  context  there  is  anoth  thread  that  check  for  insid  the  monitor  and  will  exit  in  that  case  this  doe  not  look  to  be  a  correct  pattern  to  me  if  an  interrupt  happen  it  will  set  the  interrupt  status  again  so  when  it  return  to  anoth  interruptedexcept  will  come  etc  etc  etc  therefor  it  can  never  go  to  truli  wait  state  ie  it  will  never  releas  the  monitor  this  may  result  in  an  infinit  loop  as  the  other  thread  cannot  set  mexit  to  true  becaus  it  can  never  enter  sobject  monitor  so  i  think  that  the  call  is  an  error  it  must  not  be  use  here  am  i  miss  someth  note  that  the  code  snippet  is  a  part  of  the  offici  android  framework  sourc  codeactu  the  situat  is  wors  becaus  the  same  pattern  is  use  in  android  when  your  gl  render  start  the  offici  sourc  code  of  you  can  reproduc  the  bug  in  a  similar  way  make  sure  your  ui  thread  has  it  interrupt  status  flag  yet  then  add  your  glsurfaceview  and  start  the  gl  render  via  but  on  some  devic  make  sure  your  glsurfaceview  has  status  otherwis  render  will  not  start  if  you  follow  the  abov  step  your  ui  thread  will  end  up  in  an  infinit  loop  becaus  the  abovequot  code  will  keep  generat  an  due  to  and  therefor  the  gl  thread  will  never  be  abl  to  set  to  fals  accord  to  my  test  it  seem  that  such  an  infinit  loop  or  at  least  such  messag  in  logcat  interest  someon  had  an  unknown  poorlydefin  issu  on  stackoverflow  earlier  which  might  be  relat  isnt  it  possibl  that  perhap  his  ui  thread  had  it  interrupt  flag  set  to  true  and  he  was  use  a  glsurfaceview  for  the  map  he  mention  just  an  assumpt  a  possibl  scenario  ,  stringliter  stringdatatyp  simpleassignmentexpress  stringaddit  trycatchstat  objectmethodinvoc 