 question  ,  "  public  void  addsubelement  (node  node){  if  (node  instanceof  e)  subelements.add((e)node);  else  //doing  extra  steps  for  occasional  non-e  nodes  like  discarding  them  silently  without  castexception;  };public  void  addsubelement  (node  node){  if  (node  instanceof  subnode1)  subelements.add((subnode1)node);  if  (node  instanceof  subnode2)  subelements.add((subnode2)node);  //if  (node  instanceof  subnode50....  };  public  void  addsubelement  (node  node){  subelements.add((e)node.autocasttosubclassofabstract(""node""));  //should  throw  castexception  if  non-e  };public  void  addsubelement  (node  node){  subelements.add(node.autocastto(""e""));  //should  throw  castexception  if  non-e  }"  ,i  have  super  abstract  class  node  and  type  of  subclass  subnodei  have  a  generic  class  e  extend  node  which  has  a  privat  var  list  and  a  method  which  unfortun  has  to  accept  superclass  node  alway  cannot  move  it  to  just  e  ani  solut  reflect  abl  to  compil  without  warn  throw  a  castexcept  instead  of  ad  ani  object  due  to  type  erasur  i  donþƒt  want  to  have  to  write  same  function  for  ani  type  of  subclass  it  would  be  so  nice  have  a  method  like  or  ,    simplevari  objectvari  objectmethodinvoc  actualmethodparamet  explicittypecast     classdefinit  privateclassspecifi  staticclassspecifi  privatefieldspecifi  instancefield  simplevari  instancefieldinitializationstat  javautilarraylist  simpleassignmentexpress  genericobjectcreationstat  formalmethodparamet  constructordefinit  publicconstructorspecifi  instancefieldinvoc  thisrefer  methoddefinit  publicmethodspecifi  voiddatatyp  ifelsestat  objectmethodinvoc  actualmethodparamet  javautilarraylistadd  explicittypecast  throwstat  objectcreationstat  constructorcal     formalmethodparamet  