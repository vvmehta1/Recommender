 question  ,  "10  +  5  =  159  +  6  =  158  +  7  =  15;  for  example:  assuming  a  number  set  of  20'  '  11'  '  8'  '  7'  '  6'  '51.  target  is  202.  read  in  number  from  set:  114.  11  <  20'  '  add  11  to  solution5.  new  target  is  9  (20  -  11)6.  read  in  the  next  number:  87.  8  is  less  than  9'  '  add  8  to  solution8.  new  target  is  1  (20  -  19)9  read  in  7'  '  7  is  larger  than  1'  '  do  not  add  7;  import  java.io.printwriter;import  java.util.arraylist;import  javax.swing.joptionpane;public  class  knapsack{public  static  void  main(string[]  args){//read  in  user  input  firstint[]  temparray;string  userinput  =  joptionpane.showinputdialog(""enter  a  list  of  numbers  delimited  by  a  single  space."");string[]  splitelements  =  userinput.split(""\s+"");//user  array  will  contain  the  exact  amount  of  //numbers  as  long  as  extra  spaces  are  not  entered.  temparray  =  new  int[splitelements.length];for(int  i  =  0;  i  <  temparray.length;  i++){temparray[i]  =  integer.parseint(splitelements[i]);}recursion  recobj  =  new  recursion(temparray);}}class  recursion{private  int[]  weightarray;private  int  []  solutionarray;private  int  counter;private  int  maingoal;private  int  []  backupoforiginal;private  int  solutionarraycounter;private  arraylist  numberlist;private  arraylist  previoussolutionsfound;private  int  passthrough;private  int  baseiterator;private  arraylist  distinctsolutions;public  recursion(int[]  paramarray){weightarray  =  paramarray;backupoforiginal  =  weightarray;solutionarray  =  new  int[paramarray.length];//start  at  index  1  where  the  first  number  technically  starts.  counter  =  0;//keep  track  of  main  goalmaingoal  =  weightarray[0];solutionarraycounter  =  0;passthrough  =  0;baseiterator  =  0;distinctsolutions  =  new  arraylist();numberlist  =  new  arraylist();previoussolutionsfound  =  new  arraylist();for(int  i  =  1;  i  <  weightarray.length;  i++){numberlist.add(weightarray[i]);}//begin  the  recursive  problem.checkforsums(maingoal'  '  numberlist);}public  void  checkforsums(int  targetvalue'  '  arraylist  weightarray){int  numberread  =  (integer)  weightarray.get(counter);targetvalue  =  computetarget();counter++;//base  case  if  any  number  to  read//is  greater  than  the  main  target  value//remove  itif(numberread  >  maingoal){weightarray.remove(counter);counter--;}if(numberread  <=  targetvalue){addtosolution(numberread);checkforpossiblesolution();//add  the  item  to  the  solution}//counter++;if(counter  ==  weightarray.size()){passthrough++;counter  =  passthrough  +  1;removeonefromsolution();}//advance  forward  one  positionif(passthrough  ==  weightarray.size()  -  1){counter  =  0;passthrough  =  0;weightarray  =  rebuildarraylist(weightarray);for(int  i  =  0;  i  <  baseiterator;  i++){weightarray.remove(0);}baseiterator++;resetsolutionarray();}if(baseiterator  ==  this.weightarray.length  -  2){//should  be  completely  donereturn;}checkforsums(targetvalue'  '  weightarray);}public  void  resetsolutionarray(){solutionarraycounter  =  0;for(int  i  =  0;  i  <  solutionarray.length;  i++){solutionarray[i]  =  0;}}public  void  checkforpossiblesolution(){if(sumofsolutionsfound()  ==  maingoal){printfoundsolution();removedowntobasenumber();}else{system.out.println(""no  solution  found  yet."");}}public  void  removeonefromsolution(){if(solutionarraycounter  >  1){solutionarraycounter--;}if(solutionarraycounter  >  1){solutionarray[solutionarraycounter]  =  0;}}public  void  removedowntobasenumber(){while(solutionarraycounter  >  1){solutionarraycounter--;solutionarray[solutionarraycounter]  =0;}}public  int  sumofsolutionsfound(){int  sumofsolutions  =  0;for(int  i  =  0;  i  <  solutionarray.length;  i++){sumofsolutions  +=  solutionarray[i];}return  sumofsolutions;}public  arraylist<integer>  rebuildarraylist(arraylist<integer>  paramlist){paramlist  =  new  arraylist();for(int  i  =  1;  i  <  weightarray.length;  i++){paramlist.add(weightarray[i]);}return  paramlist;}public  void  printfoundsolution(){stringbuilder  tomessagebox  =  new  stringbuilder();system.out.print(""found  a  solution!  "");tomessagebox.append(""found  a  solution!  "");for(int  i  =  0;  i  <  solutionarray.length;  i++){system.out.print(solutionarray[i]  +  ""  "");tomessagebox.append(solutionarray[i]  +  ""  "");}string  finishedmessage  =  tomessagebox.tostring();boolean  displaycurrentsolution  =  true;for(int  i  =  0;  i  <  previoussolutionsfound.size();  i++){string  previoussolution  =  previoussolutionsfound.get(i).tostring();if(finishedmessage.equals(previoussolution)){displaycurrentsolution  =  false;}}previoussolutionsfound.add(finishedmessage);if(displaycurrentsolution  ==  true){distinctsolutions.add(finishedmessage);joptionpane.showmessagedialog(null'  'finishedmessage'  '  ""solution  for  target:  ""  +  maingoal'  '  joptionpane.information_message);}}public  void  addtosolution(int  value){solutionarray[solutionarraycounter]  =  value;solutionarraycounter++;}public  int  computetarget(){int  sumofsolutions  =  0;for(int  i  =  0;  i  <  solutionarray.length;  i++){sumofsolutions  +=  solutionarray[i];}int  numbersneededtoreachmaingoal  =  maingoal  -  sumofsolutions;return  numbersneededtoreachmaingoal;}}"  ,im  struggl  with  a  homework  assign  and  i  believ  i  am  vast  overcompl  the  solut  and  need  some  help  from  anyon  will  to  offer  it  let  me  explain  some  ground  rule  for  the  assignmentbelow  is  a  link  to  anoth  post  that  has  the  exact  problem  informat  a  set  of  number  will  be  given  such  as  for  exampl  the  first  number  alway  correspond  to  the  target  or  capac  of  the  knapsack  what  i  must  do  is  recurs  check  all  the  number  and  see  if  ani  of  the  number  add  up  to  the  capac  of  the  knapsack  if  they  do  i  am  to  print  the  number  that  add  up  to  the  target  sum  and  when  research  this  problem  most  post  solv  for  one  solut  let  me  explain  the  ground  rule  for  the  assignmentthi  assign  must  be  done  recurs  no  except  all  solut  must  be  foundth  number  are  sort  from  highest  to  lowest  in  the  there  was  onli  one  solut  of  howev  given  a  data  set  such  as  there  exist  multipl  solut  such  as  essenti  there  are  two  problem  to  solv  im  have  some  troubl  get  my  mind  around  what  the  author  in  this  solut  was  sayingwhat  im  fail  to  understand  is  what  do  i  do  if  i  dont  add  a  numberyou  take  an  item  you  remov  the  item  from  your  list  and  decreas  the  capacityyou  dont  take  an  item  you  remov  the  item  from  your  list  but  you  dont  decreas  the  capacityin  my  code  in  either  case  of  take  item  or  dont  take  item  i  do  not  remov  an  item  from  my  weight  list  and  i  think  this  is  my  problem  to  begin  with  ill  post  some  code  ive  work  on  below  for  this  assign  as  you  can  see  there  is  is  an  over  bloat  solut  that  doe  not  work  as  eleg  as  the  real  solut  should  if  anyon  could  provid  advic  or  insight  on  how  to  realli  solv  this  problem  with  the  assign  paramet  mention  abov  i  would  great  appreci  it  thank  you  ,  simpleassignmentexpress  objectvari  simplevari  lessexpress  subtractexpress  importstat  javautilarraylist  formalmethodparamet  staticmethodspecifi  intdatatyp  forstat  arraylength  postincrementexpress  arrayel  ifelsestat  equalexpress  javalangsystemoutprintln  actualmethodparamet  stringliter  stringdatatyp  ifstat  greaterexpress  postdecrementexpress  whilestat  addassignmentexpress  returnstat  objectcreationstat  constructorcal  objectmethodinvoc  javalangsystemoutprint  notexpress  stringaddit  stringvari  booleandatatyp  true  javalangstringequ  fals 