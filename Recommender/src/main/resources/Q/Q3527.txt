 question  ,  "class  test  {public  static  void  main(string[]  args)  {test1();}public  static  void  test1()  {fridge  fridge  =  new  fridge(4);hunter  hunter1  =  new  hunter(""hunter1""'  '  4'  '  fridge);hunter  hunter2  =  new  hunter(""hunter2""'  '  7'  '  fridge);thread  hunterthread1  =  new  thread(hunter1);thread  hunterthread2  =  new  thread(hunter2);hunterthread1.start();hunterthread2.start();try  {  thread.sleep(1000);  }  catch  (interruptedexception  e)  {}hunterthread1.interrupt();hunterthread2.interrupt();system.out.println(fridge.getsize());system.out.println(hunter1.getworktime());system.out.println(hunter2.getworktime());}};  class  hunter  extends  worker  {private  int  worktime;private  fridge  fridge;public  hunter(string  name'  '  int  worktime'  '  fridge  fridge)  {super(name);this.worktime  =  worktime;this.fridge  =  fridge;}public  int  getworktime()  {return  worktime;}public  void  run()  {while  (worktime  >  0)  {/**  each  hunt  takes  a  random  amount  of  time  (1-50  ms)  **/try  {  thread.sleep(workgen());  }  catch  (interruptedexception  e)  {}/**  add  new  wild  boars  **/try  {  fridge.add(new  wildboar());  }  catch  (interruptedexception  e)  {}worktime--;/**  if  thread  is  interupted  break  the  loop  **/if(  thread.currentthread().isinterrupted()){break;}}}};  import  java.util.stack;class  fridge  extends  storage  {private  stack<wildboar>  boars;public  fridge(int  cap)  {super(cap);boars  =  new  stack<wildboar>();}public  int  getcap()  {return  cap;}public  int  getsize()  {return  boars.size();}public  boolean  hasfreespace()  {if  (  boars.size()  <  cap  )return  true;elsereturn  false;}public  synchronized  void  add(wildboar  boar)  throws  interruptedexception  {/**  if  there's  no  free  space  available  wait  **/while  (  !hasfreespace()  )  {wait();}/**  once  there's  free  space  available  add  new  item  **/boars.add(boar);}public  synchronized  wildboar  remove()  {return  boars.pop();}};  abstract  class  worker  implements  runnable  {private  string  name;public  worker(string  name)  {this.name  =  name;}public  string  getname()  {return  name;}public  int  workgen()  {return  1  +  (int)(math.random()  *  (50  -  1));}}class  wildboar  {public  wildboar()  {}}abstract  class  storage  {protected  int  cap;public  storage(int  cap)  {this.cap  =  cap;}public  int  getcap()  {return  cap;}}"  ,veri  recent  ive  ask  this  question  but  wasn  unabl  to  fix  this  so  i  have  a  thread  hunter  of  them  actual  who  goe  off  to  catch  wild  boar  he  store  these  boar  in  a  contain  fridg  he  will  continu  to  do  so  until  his  work  hour  expir  howev  in  case  the  fridg  is  full  he  has  to  wait  the  aim  is  to  wait  until  a  wild  boar  is  remov  from  the  fridg  but  if  it  take  more  then  second  of  wait  test  must  be  termin  so  everyth  work  except  one  thing  after  run  test  and  interrupt  these  thread  the  program  still  continu  to  run  so  how  do  i  complet  terminatestop  these  thread  test  class  main  hunter  class  fridg  class  addit  class  for  compil  ,  simpleassignmentexpress  objectcreationstat  constructorcal  extendsspecif  privatefieldspecifi  instancefield  intdatatyp  simplevari  formalmethodparamet  constructordefinit  publicconstructorspecifi  importstat  classdefinit  superclassconstructorcal  genericobjectcreationstat  methoddefinit  publicmethodspecifi  returnstat  objectmethodinvoc  booleandatatyp  ifstat  lessexpress  true  fals  synchronizedmethodspecifi  throwsspecif  voiddatatyp  whilestat  notexpress  actualmethodparamet  abstractclassspecifi  implementsspecif  methodimplement  stringvari  stringdatatyp  instancefieldinvoc  thisrefer  addexpress    objectvari  simplevari  trycatchstat  objectmethodinvoc  actualmethodparamet  objectcreationstat  constructorcal  ifstat  