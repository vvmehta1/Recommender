 question  ,  "/*  specialized  implementations  of  map  methods  */v  get(object  key'  '  int  hash)  {if  (count  !=  0)  {  //  read-volatilehashentry<k'  'v>  e  =  getfirst(hash);while  (e  !=  null)  {if  (e.hash  ==  hash  &&  key.equals(e.key))  {v  v  =  e.value;if  (v  !=  null)return  v;return  readvalueunderlock(e);  //  recheck}e  =  e.next;}}return  null;};  /**  *  reads  value  field  of  an  entry  under  lock.  called  if  value  *  field  ever  appears  to  be  null.  this  is  possible  only  if  a  *  compiler  happens  to  reorder  a  hashentry  initialization  with  *  its  table  assignment'  '  which  is  legal  under  memory  model  *  but  is  not  known  to  ever  occur.  */v  readvalueunderlock(hashentry<k'  'v>  e)  {lock();try  {return  e.value;}  finally  {unlock();}};  /**  *  concurrenthashmap  list  entry.  note  that  this  is  never  exported  *  out  as  a  user-visible  map.entry.  *  *  because  the  value  field  is  volatile'  '  not  final'  '  it  is  legal  wrt  *  the  java  memory  model  for  an  unsynchronized  reader  to  see  null  *  instead  of  initial  value  when  read  via  a  data  race.although  a  *  reordering  leading  to  this  is  not  likely  to  ever  actually  *  occur'  '  the  segment.readvalueunderlock  method  is  used  as  a  *  backup  in  case  a  null  (pre-initialized)  value  is  ever  seen  in  *  an  unsynchronized  access  method.  */static  final  class  hashentry<k'  'v>  {final  k  key;final  int  hash;volatile  v  value;final  hashentry<k'  'v>  next;hashentry(k  key'  '  int  hash'  '  hashentry<k'  'v>  next'  '  v  value)  {this.key  =  key;this.hash  =  hash;this.next  =  next;this.value  =  value;};  tab[index]  =  new  hashentry<k'  'v>(key'  '  hash'  '  first'  '  value);;  concurrentlinkedqueue  queue  =  new  concurrentlinkedqueue();thread1:person  p=new  person(""name""'  '""student"");queue.offer(new  person());thread2:person  p  =  queue.poll();"  ,im  look  into  concurrenthashmap  implement  and  have  a  thing  make  me  confus  and  and  hashentri  constructorput  implement  i  confus  at  hashentri  comment  as  onc  hashentri  is  construct  all  final  field  will  be  visibl  to  all  other  thread  field  is  volatil  so  i  think  it  visibl  to  other  thread  too  other  point  is  the  reorder  he  said  is  hashentri  object  refer  can  be  assign  to  tab  befor  it  is  full  construct  so  result  is  other  thread  can  see  this  entri  but  evalu  can  be  null  i  read  articl  and  it  good  but  do  i  need  to  care  about  a  case  like  this  is  there  a  chanc  that  thread  receiv  an  unfinishedconstruct  person  object  just  like  hashentri  in  ,  objectvari  simplevari  simpleassignmentexpress  multiplyexpress  objectmethodinvoc  actualmethodparamet  lessexpress  null  staticclassspecifi  finalclassspecifi  constant  intdatatyp  volatilefieldspecifi  instancefield  instancefieldinvoc  thisrefer  arrayel  objectcreationstat  constructorcal       simpleassignmentexpress  