 question  ,  "atomicinteger;  atomicinteger  counter  =  new  atomicinteger(0);counterthread  ct1  =  new  counterthread(counter'  '  ""a"");counterthread  ct2  =  new  counterthread(counter'  '  ""b"");counterthread  ct3  =  new  counterthread(counter'  '  ""c"");ct1.start();ct2.start();ct3.start();;  public  class  counterthread  extends  thread{  private  atomicinteger  _count;private  string  _id;public  counterthread(atomicinteger  count'  '  string  id){_count  =  count;_id  =  id;}public  void  run(){while(_count.get()  <  1000){system.out.println(_id  +  "":  ""  +  _count.incrementandget());thread.yield();}}};  thread.yield();  _count;  a:  1b:  2c:  3a:  4...;  a;  _count;  b;  thread.yield()"  ,in  an  effort  to  practic  my  rusti  java  i  want  to  tri  a  simpl  multithread  share  data  exampl  and  i  came  across  someth  that  surpris  me  basic  we  have  a  share  counter  between  three  thread  that  each  take  turn  increment  and  print  the  counter  i  expect  that  when  each  thread  execut  that  it  would  give  over  execut  to  anoth  thread  to  increment  like  this  instead  i  got  output  where  would  increment  time  then  pass  it  off  to  sometim  all  three  thread  would  take  turn  consist  but  sometim  one  thread  would  domin  for  sever  increment  whi  doesnt  alway  yield  process  over  to  anoth  thread  ,  simpleassignmentexpress  objectcreationstat  constructorcal  actualmethodparamet  extendsspecif  privatefieldspecifi  instancefield  simplevari  stringvari  stringdatatyp  formalmethodparamet  constructordefinit  publicconstructorspecifi  whilestat  objectmethodinvoc  lessexpress  javalangsystemoutprintln  addexpress  stringliter  multiplyexpress    