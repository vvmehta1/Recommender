 question  ,  "import  java.util.arraylist;public  class  ourroom{private  ourroom  exits[];private  string  name;private  static  arraylist<ourroom>  list;public  ourroom(){this(null);}public  ourroom(string  name){this.name  =  name;this.list  =  new  arraylist<ourroom>();exits  =  new  ourroom[direction.values().length];for(ourroom  exit  :  exits){exit  =  null;}}  public  void  connectto(ourroom  theotherroom'  '  direction  direction){exits[direction.ordinal()]  =  theotherroom;theotherroom.exits[direction.getopposite().ordinal()]  =  this;}public  ourroom  getexit(direction  direction){return  exits[direction.ordinal()];}public  boolean  lookexit(direction  direction){return  exits[direction.ordinal()]  !=  null;}public  string  getname()  {return  name;}public  ourroom  solverecursively(ourroom  exit)  {list.add(this);if(this  ==  exit)  {return  this;}else  {  ourroom  temp  =  null;if(lookexit(direction.east))  {temp  =  exits[direction.east.ordinal()].solverecursively(exit);}  else  if(lookexit(direction.up))  {temp  =  exits[direction.up.ordinal()].solverecursively(exit);}else  if(lookexit(direction.south))  {temp  =  exits[direction.south.ordinal()].solverecursively(exit);  }  else  if(lookexit(direction.down))  {temp  =  exits[direction.down.ordinal()].solverecursively(exit);}else  if(lookexit(direction.west))  {temp  =  exits[direction.west.ordinal()].solverecursively(exit);}  else  if(lookexit(direction.north))  {temp  =  exits[direction.north.ordinal()].solverecursively(exit);  }return  temp;}}public  arraylist<ourroom>  getlist()  {return  list;}};  public  enum  direction{north'  '  south'  '  east'  '  west'  '  up'  '  down;public  direction  getopposite(){switch(this){case  north:return  south;case  south:return  north;case  east:return  west;case  west:return  east;case  up:return  down;case  down:return  up;default:return  this;}}};  import  java.util.arraylist;import  java.util.iterator;public  class  ourmaze{private  ourroom  entrance'  '  exit;public  ourmaze(){this(1);}public  ourmaze(int  mazenumber){entrance  =  null;exit  =  null;switch(mazenumber){case  0:break;case  1:this.buildmaze1();break;  default:}}public  ourroom  getentrance(){return  entrance;}public  ourroom  getexit(){return  exit;}public  iterator<ourroom>  findpathrecursively()  {entrance.solverecursively(exit);arraylist<ourroom>  list  =  entrance.getlist();  return  list.iterator();}private  void  buildmaze1(){ourroom  room1'  '  room2;room1  =  new  ourroom(""room  1"");room2  =  new  ourroom(""room  2"");room1.connectto(room2'  '  direction.north);entrance  =  room1;exit  =  room2;}public  static  void  main(string[]  args)  {ourmaze  maze  =  new  ourmaze(1);}}"  ,i  have  an  assign  where  i  am  suppos  to  be  abl  to  display  the  path  of  a  maze  from  the  entranc  to  the  exit  and  i  have  gotten  it  to  work  to  a  degre  but  when  the  maze  get  more  complic  with  dead  end  and  such  the  program  goe  into  infinit  recurs  if  you  could  give  me  ani  help  to  point  me  in  the  right  direct  it  would  be  much  appreci  mu  current  theori  can  be  found  in  the  room  class  here  is  the  room  class  where  the  refer  to  each  room  connect  the  maze  are  store  kind  of  like  a  link  list  link  in  direct  north  south  east  west  up  and  down  here  is  the  direct  enum  and  here  is  an  exampl  of  how  the  maze  is  built  ,  objectvari  simplevari  arrayel  objectmethodinvoc  simpleassignmentexpress  formalmethodparamet  returnstat  booleandatatyp  notequalexpress  null  stringdatatyp  actualmethodparamet  ifelsestat  equalexpress  nulliniti  ifelseifstat  ifstat  publicfieldspecifi  instancefield  javautilarraylist  importstat  privatefieldspecifi  intdatatyp  switchstat  caseclaus  breakstat  defaultclaus  privatemethodspecifi  objectcreationstat  constructorcal  stringliter  staticmethodspecifi    intdatatyp  simplevari  ifstat  objectvari  actualmethodparamet  subtractexpress  instancefield  instancefieldinitializationstat  simpleassignmentexpress  arrayel        