 question  ,  "public  class  sievegenerator{static  int  n  =  50;public  static  void  main(string  args[]){int  cores  =  runtime.getruntime().availableprocessors();int  f[]  =  new  int[n];//fill  array  with  0'  '1'  '2...f.lengthfor(int  j=0;j<f.length;j++){f[j]=j;}f[0]=0;f[1]=0;//eliminate  these  casesint  p=2;removenonprime  []t  =  new  removenonprime[cores];for(int  i  =  0;  i  <  cores;  i++){t[i]  =  new  removenonprime(f'  'p);}while(p  <=  (int)(math.sqrt(n))){t[p%cores].start();//problem  here  because  you  cannot  start  a  thread  which  has  already  started(illegalthreadstateexception)try{t[p%cores].join();}catch(exception  e){}//get  the  next  primep++;while(p<=(int)(math.sqrt(n))&&f[p]==0)p++;}//count  primesint  total  =  0;system.out.println();for(int  j=0;  j<f.length;j++){if(f[j]!=0){total++;}}system.out.printf(""number  of  primes  up  to  %d  =  %d""'  'f.length'  'total);}}class  removenonprime  extends  thread{int  k;int  arr[];public  removenonprime(int  arr[]'  '  int  k){this.arr  =  arr;this.k  =  k;}public  void  run(){int  j  =  k*k;while(j<arr.length){if(arr[j]%k  ==  0)arr[j]=0;j=j+arr[k];}}};  illegalthreadstateexception"  ,hi  im  get  an  when  i  run  my  code  and  ive  figur  it  becaus  i  am  tri  to  start  a  thread  that  has  alreadi  been  start  so  how  could  i  kill  or  stop  the  thread  each  time  to  get  around  this  problem  ,  simpleassignmentexpress  arraylength  extendsspecif  instancefield  intdatatyp  simplevari  instancefieldinvoc  thisrefer  multiplyexpress  whilestat  lessexpress  ifstat  arrayel  modulusexpress  equalexpress  addexpress             ifstat  notexpress  objectmethodinvoc  arrayel  modulusexpress  