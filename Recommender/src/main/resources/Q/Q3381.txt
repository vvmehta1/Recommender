 question  ,  "public  class  threadmeasuring  {private  static  final  int  task_time  =  1;  //microsecondsprivate  static  class  batch  implements  runnable  {countdownlatch  countdown;public  batch(countdownlatch  countdown)  {this.countdown  =  countdown;}@overridepublic  void  run()  {  long  t0  =system.nanotime();long  t  =  0;while(t<task_time*1e6){  t  =  system.nanotime()  -  t0;  }if(countdown!=null)  countdown.countdown();}}public  static  void  main(string[]  args)  {threadfactory  threadfactory  =  new  threadfactory()  {int  counter  =  1;@overridepublic  thread  newthread(runnable  r)  {thread  t  =  new  thread(r'  '  ""executor  thread  ""  +  (counter++));return  t;}};//  the  total  duty  to  be  divided  in  tasks  is  fixed  (problem  dependent).  //  increase  ntasks  will  mean  decrease  the  task  time  proportionally.  //  4  is  an  arbitrary  example.//  this  tasks  will  be  executed  thousands  of  times'  '  inside  a  loop  alternating  //  with  serial  processing  that  needs  their  result  and  prepare  the  next  ones.int  ntasks  =  4;  int  nthreads  =  2;int  ncores  =  runtime.getruntime().availableprocessors();if  (nthreads<ncores)  ncores  =  nthreads;  batch  serial  =  new  batch(null);long  serialtime  =  system.nanotime();serial.run();serialtime  =  system.nanotime()  -  serialtime;executorservice  executor  =  executors.newfixedthreadpool(  nthreads'  '  threadfactory  );countdownlatch  countdown  =  new  countdownlatch(ntasks);arraylist<batch>  batches  =  new  arraylist<batch>();for  (int  i  =  0;  i  <  ntasks;  i++)  {batches.add(new  batch(countdown));}long  start  =  system.nanotime();for  (batch  r  :  batches){executor.execute(r);}//  wait  for  all  threads  to  finish  their  tasktry  {countdown.await();}  catch  (interruptedexception  e)  {//  todo  auto-generated  catch  blocke.printstacktrace();}long  tmeasured  =  (system.nanotime()  -  start);system.out.println(""task  time=  ""  +  task_time  +  ""  ms"");system.out.println(""number  of  tasks=  ""  +  ntasks);system.out.println(""number  of  threads=  ""  +  nthreads);system.out.println(""number  of  cores=  ""  +  ncores);system.out.println(""measured  time=  ""  +  tmeasured);system.out.println(""theoretical  serial  time=  ""  +  task_time*1000000*ntasks);system.out.println(""theoretical  parallel  time=  ""  +  (task_time*1000000*ntasks)/ncores);system.out.println(""speedup=  ""  +  (serialtime*ntasks)/(double)tmeasured);executor.shutdown();}  }"  ,first  and  onc  more  thank  to  all  that  alreadi  answer  my  question  i  am  not  a  veri  experienc  programm  and  it  is  my  first  experi  with  multithread  i  got  an  exampl  that  is  work  quit  like  my  problem  i  hope  it  could  eas  our  case  hereinstead  of  do  the  calcul  each  batch  just  wait  for  some  given  time  the  program  calcul  the  that  would  allway  be  in  theori  but  can  get  less  than  actual  a  if  the  tasktim  is  smallmi  calcul  take  at  the  top  ms  and  are  common  faster  for  ms  i  find  a  littl  speedup  of  around  but  in  practic  with  my  program  i  notic  a  the  structur  of  this  code  is  veri  similar  to  my  program  so  if  you  could  help  me  to  optimis  the  thread  handl  i  would  be  veri  grate  kind  regard  below  the  origin  question  hi  i  would  like  to  use  multithread  on  my  program  sinc  it  could  increas  it  effici  consider  i  believ  most  of  it  run  time  is  due  to  independ  calcul  my  program  has  thousand  of  independ  calcul  sever  linear  system  to  solv  but  they  just  happen  at  the  same  time  by  minor  group  of  dozen  or  so  each  of  this  group  would  take  some  milisecond  to  run  after  one  of  these  group  of  calcul  the  program  has  to  run  sequenti  for  a  littl  while  and  then  i  have  to  solv  the  linear  system  again  actual  it  can  be  seen  as  these  independ  linear  system  to  solv  are  insid  a  loop  that  iter  thousand  of  time  altern  with  sequenti  calcul  that  depend  on  the  previous  result  my  idea  to  speed  up  the  program  is  to  comput  these  independ  calcul  in  parallel  thread  by  divid  each  group  into  the  number  of  processor  i  have  avail  batch  of  independ  calcul  so  in  principl  there  isnt  queu  at  all  i  tri  use  the  fixedthreadpool  and  cachedthreadpool  and  it  got  even  slower  than  serial  process  it  seem  to  take  too  much  time  creat  new  tread  each  time  i  need  to  solv  the  batch  is  there  a  better  way  to  handl  this  problem  these  pool  ive  use  seem  to  be  proper  for  case  when  each  thread  take  more  time  instead  of  thousand  of  smaller  thread  thanksbest  regard  ,  stringliter  stringdatatyp  simpleassignmentexpress  actualmethodparamet  stringaddit  postincrementexpress  returnstat       classdefinit  implementsspecif  methodimplement  privatefieldspecifi  finalfieldspecifi  instancefield  simplevari  formalmethodparamet  constructordefinit  simpleassignmentexpress  methoddefinit  publicmethodspecifi  voiddatatyp  whilestat  true  actualmethodparamet  objectmethodinvoc  genericobjectcreationstat  intdatatyp  objectcreationstat  constructorcal  arraycreationstat  arrayvari  arraydatatyp  forstat  lessexpress  postincrementexpress  arrayel     objectmethodinvoc  longdatatyp  simpleassignmentexpress  subtractexpress  javalangsystemoutprintln  actualmethodparamet  stringliter  stringdatatyp  objectvari  simplevari  stringaddit  divideexpress  addexpress  intdatatyp  forstat  lessexpress  multiplyexpress  postincrementexpress  constant  constantinitializationstat  objectcreationstat  constructorcal  instancefield  instancefieldinitializationstat  arraycreationstat  arrayvari  arraydatatyp  doubledatatyp  javalangstringlength  arraylength     simpleassignmentexpress     instancefield  simplevari  instancefieldinitializationstat  simpleassignmentexpress  objectmethodinvoc  objectcreationstat  constructorcal  actualmethodparamet  stringvari  stringdatatyp  