 question  ,  private  volatile  fieldtype  field;fieldtype  getfield()  {fieldtype  result  =  field;if  (result  ==  null)  {//  first  check  (no  locking)synchronized(this)  {result  =  field;if  (result  ==  null)//  second  check  (with  locking)field  =  result  =  computefieldvalue();}}return  result;};  private  fieldtype  field;  //  non  volatileprivate  volatile  boolean  fence  =  false;fieldtype  getfield()  {if  (field  ==  null)  {//  first  check  (no  locking)  //  no  volatile  readsynchronized(this)  {  //inside  synch  block  no  problem  of  visibilty  will  latest  //valueof  field  if  (field  ==  null)  {//  second  check  (with  locking)object  obj  =computefieldvalue();  fence  =  true;  //  any  volatile  write  will  take.  this  will  make  sure  statements  are  //not  reorder  with  setting  field  as  non  null.field  =  (fieldtype)obj;  //  this  will  be  only  set  after  computefieldvalue  has  been  //completed  fully  }}}return  field;}  ,below  code  snippet  is  from  effect  java  nd  edit  doubl  check  lock  doublecheck  idiom  for  lazi  initi  of  instanc  fieldsfrom  what  i  know  the  main  problem  with  doubl  check  lock  is  the  reorder  insid  second  check  lock  so  that  the  otherthread  might  see  the  valu  of  fieldresult  as  set  which  may  be  infact  still  be  in  execut  to  avoid  this  we  make  the  refer  of  field  as  volatil  to  gurante  visibl  and  reorder  but  this  can  be  achiev  by  the  below  code  alsoso  after  when  the  initi  have  been  done  then  no  thread  will  have  to  for  volatil  read  or  synchron  overhead  pleas  see  if  my  assumpt  are  right  or  not  ,  privatefieldspecifi  volatilefieldspecifi  instancefield  simplevari    objectvari  simplevari  simpleassignmentexpress  