 question  ,  final;  final;  final;  (1);  (2);  class  finalfieldexample  {  final  int  x;  int  y;  static  finalfieldexample  f;public  finalfieldexample()  {  x  =  3;  y  =  4;  }  static  void  writer()  {  f  =  new  finalfieldexample();  }  static  void  reader()  {  if  (f  !=  null)  {  int  i  =  f.x;  //  guaranteed  to  see  3  int  j  =  f.y;  //  could  see  0  }  }  };  final;  (3);  final;  y;  final;  class  finalfieldexample  {  final  int  x;  final  int  y;  ...;  reader();  if  (f  !=  null)  {  int  i  =  f.x;  //  guaranteed  to  see  3int  j  =  f.y;  //  guaranteed  to  see  4'  '  isn't  it???;  f;  f  ,everi  one  of  you  know  about  this  featur  of  that  sometim  refer  to  object  could  receiv  valu  constructor  of  this  object  is  finish  in  we  can  also  read  and  just  after  that  in  jls  the  exampl  follow  which  demonstr  how  field  is  not  guarante  to  be  initi  exampl  also  in  questionansw  mr  gray  wrote  accord  to  statement  we  should  avoid  share  refer  to  object  befor  it  constructor  is  finish  accord  to  jlss  given  exampl  and  conclus  it  seem  that  we  can  safe  share  refer  to  object  it  constructor  is  finish  ie  when  all  it  field  are  what  i  exact  mean  if  we  will  modifi  class  in  exampl  such  way  that  field  will  be  also  henc  in  method  it  will  be  guarante  that  if  so  whi  we  should  avoid  write  refer  to  object  befor  it  constructor  is  finish  accord  to  when  all  field  of  are  final  ,    classdefinit  finalfieldspecifi  instancefield  intdatatyp  simplevari  staticfieldspecifi  classfield  constructordefinit  publicconstructorspecifi  simpleassignmentexpress  methoddefinit  staticmethodspecifi  voiddatatyp  objectcreationstat  constructorcal     simpleassignmentexpress  objectvari  simplevari  constant     