 question  ,  "stop();  java.nio.asynchronouscloseexception;  stop();  public  void  run()  {inetsocketaddress  addr  =  new  inetsocketaddress(provider.getconnection()'  '  12354);try  {server  =  serversocketchannel.open();server.configureblocking(true);server.socket().bind(addr);parent.setip(addr.getaddress().gethostaddress().tostring());password  =  generatepassword();parent.setpassword(password);parent.setstatus(""ready."");}  catch  (ioexception  e)  {parent.die(""could  not  start  server:  ""  +  e.getmessage());runner  =  null;}while  (runner  ==  thread.currentthread())  {try  {socketchannel  sc  =  server.accept();if  (available)  {session  =  new  receivesession(this'  '  sc'  '  password'  '  addr.getaddress());session.start();available  =  false;}  else  {new  receivebusyhandler(sc).start();}}  catch  (ioexception  e)  {synchronized  (swallowexception)  {if  (!swallowexception)  {parent.showerror(e.tostring());}available  =  true;}}}}public  void  stop()  throws  ioexception  {synchronized  (swallowexception)  {swallowexception  =  true;runner  =  null;if  (server  !=  null)  {server.socket().close();server.close();}swallowexception  =  false;system.out.println(""server  down"");}};  swallowexception;  boolean;  stop();  swallowexception;  true;  false;  object;  wait()/notify();  public  void  run()  {inetsocketaddress  addr  =  new  inetsocketaddress(provider.getconnection()'  '  12354);try  {server  =  serversocketchannel.open();server.configureblocking(true);server.socket().bind(addr);parent.setip(addr.getaddress().gethostaddress().tostring());password  =  generatepassword();parent.setpassword(password);parent.setstatus(""ready."");}  catch  (ioexception  e)  {parent.die(""could  not  start  server:  ""  +  e.getmessage());runner  =  null;}while  (runner  ==  thread.currentthread())  {try  {socketchannel  sc  =  server.accept();if  (available)  {session  =  new  receivesession(this'  '  sc'  '  password'  '  addr.getaddress());session.start();available  =  false;}  else  {new  receivebusyhandler(sc).start();}}  catch  (ioexception  e)  {synchronized  (lock)  {if  (!swallowexception)  {parent.showerror(e.tostring());}lock.notify();available  =  true;}}}}public  void  stop()  throws  ioexception  {synchronized  (lock)  {swallowexception  =  true;runner  =  null;if  (server  !=  null)  {server.socket().close();server.close();}while  (swallowexception)  {try  {lock.wait();swallowexception  =  false;}  catch  (interruptedexception  e)  {}}//swallowexception  =  false;system.out.println(""server  down"");}}"  ,i  have  a  server  accept  client  that  has  a  method  that  close  the  server  down  which  is  caus  a  that  id  like  to  resolv  the  method  is  call  on  a  differ  thread  which  is  what  is  caus  the  race  condit  i  believ  here  is  my  code  fyi  is  a  and  you  can  see  ive  tri  synchron  it  it  look  like  the  method  is  set  to  and  then  back  to  befor  the  except  handler  in  my  server  loop  has  a  chanc  to  access  it  updat  i  introduc  a  new  to  use  as  a  lock  and  use  to  fix  my  issu  ,  trycatchstat  simpleassignmentexpress  objectmethodinvoc  actualmethodparamet  true  stringliter  stringdatatyp  objectvari  simplevari  stringaddit  whilestat  equalexpress  ifstat  fals  objectcreationstat  constructorcal  instancefield  notexpress  throwsspecif  notequalexpress  null  javalangsystemoutprintln    simpleassignmentexpress  true  fals     trycatchstat  objectmethodinvoc  actualmethodparamet  true  simpleassignmentexpress  stringliter  stringdatatyp  objectvari  simplevari  stringaddit  fals  whilestat  ifelsestat  ifstat  objectcreationstat  constructorcal  instancefield  