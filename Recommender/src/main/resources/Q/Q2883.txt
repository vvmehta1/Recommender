 question  ,  "private  static  class  container{private  volatile  long  value;public  long  getvalue()  {return  value;}public  final  void  set(long  newvalue)  {value  =  newvalue;}}private  static  class  demothread  extends  thread  {private  container  variable;public  void  prepare()  {this.variable  =  new  container();}public  void  run()  {for(int  j  =  0;  j  <  10000000;  j++)  {variable.set(variable.getvalue()  +  system.nanotime());}}};  demothread[]  threads  =  new  demothread[numberofthreads];for(int  j  =  0;  j  <  100;  j++)  {boolean  prepareafterconstructor  =  j  %  2  ==  0;for(int  i  =  0;  i  <  threads.length;  i++)  {threads[i]  =  new  demothread();if(prepareafterconstructor)  threads[i].prepare();}for(int  i  =  0;  i  <  threads.length;  i++)  {if(!prepareafterconstructor)  threads[i].prepare();threads[i].start();}jointhreads(threads);};  public  class  unexpectedperformanceissue  {private  static  class  container{//  remove  the  volatile  keyword'  '  and  the  problem  disappears  (on  windows)//  or  gets  smaller  (on  mac  os)private  volatile  long  value;public  long  getvalue()  {return  value;}public  final  void  set(long  newvalue)  {value  =  newvalue;}}private  static  class  demothread  extends  thread  {private  container  variable;public  void  prepare()  {this.variable  =  new  container();}@overridepublic  void  run()  {long  start  =  system.nanotime();for(int  j  =  0;  j  <  10000000;  j++)  {variable.set(variable.getvalue()  +  system.nanotime());}long  end  =  system.nanotime();system.out.println(this.getname()  +  ""  completed  after  ""+((end  -  start)/1000000)  +  ""  ms."");}}public  static  void  main(string[]  args)  {system.out.println(""java  version:  ""  +  system.getproperty(""java.version""));system.out.println(""java  class  version:  ""  +  system.getproperty(""java.class.version""));system.out.println(""vm  vendor:  ""  +  system.getproperty(""java.vm.specification.vendor""));system.out.println(""vm  version:  ""  +  system.getproperty(""java.vm.version""));system.out.println(""vm  name:  ""  +  system.getproperty(""java.vm.name""));system.out.println(""os  name:  ""  +  system.getproperty(""os.name""));system.out.println(""os  arch:  ""  +  system.getproperty(""os.arch""));system.out.println(""os  version:  ""  +  system.getproperty(""os.version""));system.out.println(""processors/cores:  ""  +  runtime.getruntime().availableprocessors());system.out.println();int  numberofthreads  =  4;system.out.println(""reference  test  (single  thread):"");demothread  t  =  new  demothread();t.prepare();t.run();demothread[]  threads  =  new  demothread[numberofthreads];long  createtime  =  0'  '  starttime  =  0;for(int  j  =  0;  j  <  100;  j++)  {boolean  prepareafterconstructor  =  j  %  2  ==  0;long  overallstart  =  system.nanotime();if(prepareafterconstructor)  {system.out.println(""test  ""  +  (j+1)  +  ""'  '  ""  +  numberofthreads  +  ""  threads'  '  setting  variable  in  creation  loop"");  }  else  {system.out.println(""test  ""  +  (j+1)  +  ""'  '  ""  +  numberofthreads  +  ""  threads'  '  setting  variable  in  start  loop"");}for(int  i  =  0;  i  <  threads.length;  i++)  {threads[i]  =  new  demothread();//  either  call  demothread.prepare()  here  (in  odd  loops)...if(prepareafterconstructor)  threads[i].prepare();}for(int  i  =  0;  i  <  threads.length;  i++)  {//  or  here  (in  even  loops).  should  make  no  difference'  '  but  does!if(!prepareafterconstructor)  threads[i].prepare();threads[i].start();}jointhreads(threads);long  overallend  =  system.nanotime();long  overalltime  =  (overallend  -  overallstart);if(prepareafterconstructor)  {createtime  +=  overalltime;}  else  {starttime  +=  overalltime;}system.out.println(""overall  time:  ""  +  (overalltime)/1000000  +  ""  ms."");}system.out.println(""final  results:"");system.out.println(createtime/1000000  +  ""  ms.  when  prepare()  was  called  after  instantiation."");system.out.println(starttime/1000000  +  ""  ms.  when  prepare()  was  called  before  execution."");}private  static  void  jointhreads(thread[]  threads)  {for(int  i  =  0;  i  <  threads.length;  i++)  {try  {threads[i].join();}  catch  (interruptedexception  e)  {e.printstacktrace();}}}"  ,when  play  around  with  multithread  i  could  observ  some  unexpect  but  serious  perform  issu  relat  to  atomiclong  and  class  use  it  such  as  javautilrandom  for  which  i  current  have  no  explan  howev  i  creat  a  minimalist  exampl  which  basic  consist  of  two  class  a  class  contain  which  keep  a  refer  to  a  volatil  variabl  and  a  class  demothread  which  oper  on  an  instanc  of  contain  dure  thread  execut  note  that  the  refer  to  contain  and  the  volatil  long  are  privat  and  never  share  between  thread  i  know  that  there  no  need  to  use  volatil  here  it  just  for  demonstr  purpos  thus  multipl  instanc  of  demothread  should  run  perfect  parallel  on  a  multiprocessor  machin  but  for  some  reason  they  do  not  complet  exampl  is  at  the  bottom  of  this  post  dure  my  test  i  repeat  creat  demothread  which  are  then  start  and  join  the  onli  differ  in  each  loop  is  the  time  when  prepar  get  call  which  is  obvious  requir  for  the  thread  to  run  as  it  otherwis  would  result  in  a  nullpointerexcept  for  some  reason  if  prepar  is  execut  immedi  befor  start  the  thread  it  will  take  twice  as  more  time  to  finish  and  even  without  the  volatil  keyword  the  perform  differ  were  signific  atleast  on  two  of  the  machin  and  ose  i  test  the  code  here  a  short  summari  java  version  java  class  version  vm  vendor  sun  microsystem  inc  vm  version  b  vm  name  java  hotspottm  bit  server  vm  os  name  mac  os  x  os  arch  x  os  version  processorscor  with  volatil  keyword  final  result  ms  when  prepar  was  call  after  instanti  ms  when  prepar  was  call  befor  execut  without  volatil  keyword  final  result  ms  when  prepar  was  call  after  instanti  ms  when  prepar  was  call  befor  execut  java  version  java  class  version  vm  vendor  sun  microsystem  inc  vm  version  b  vm  name  java  hotspottm  bit  server  vm  os  name  window  os  arch  amd  os  version  processorscor  with  volatil  keyword  final  result  ms  when  prepar  was  call  after  instanti  ms  when  prepar  was  call  befor  execut  without  volatil  keyword  final  result  ms  when  prepar  was  call  after  instanti  ms  when  prepar  was  call  befor  execut  java  version  java  class  version  vm  vendor  sun  microsystem  inc  vm  version  b  vm  name  openjdk  bit  server  vm  os  name  linux  os  arch  amd  os  version  generic  processorscor  with  volatil  keyword  final  result  ms  when  prepar  was  call  after  instanti  ms  when  prepar  was  call  befor  execut  without  volatil  keyword  final  result  ms  when  prepar  was  call  after  instanti  ms  when  prepar  was  call  befor  execut  test  thread  set  variabl  in  creation  loop  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  overal  time  ms  test  thread  set  variabl  in  start  loop  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  overal  time  ms  test  thread  set  variabl  in  creation  loop  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  overal  time  ms  test  thread  set  variabl  in  start  loop  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  thread  complet  after  ms  overal  time  ms  and  so  on  sometim  one  or  two  of  the  thread  in  the  slow  loop  finish  as  expect  but  most  time  they  dont  the  given  exampl  look  theoret  as  it  is  of  no  use  and  volatil  is  not  need  here  howev  if  youd  use  a  javautilrandominst  instead  of  the  containerclass  and  call  for  instanc  nextint  multipl  time  the  same  effect  will  occur  the  thread  will  be  execut  fast  if  you  creat  the  object  in  the  thread  constructor  but  slow  if  you  creat  it  within  the  runmethod  i  believ  that  the  perform  issu  describ  in  more  than  a  year  ago  are  relat  to  this  effect  but  i  have  no  idea  whi  it  is  as  it  is  besid  that  im  sure  that  it  shouldnt  be  like  that  as  it  would  mean  that  it  alway  danger  to  creat  a  new  object  within  the  runmethod  of  a  thread  unless  you  know  that  no  volatil  variabl  will  get  involv  within  the  object  graph  profil  doesnt  help  as  the  problem  disappear  in  this  case  same  observ  as  in  and  it  also  doe  not  happen  on  a  singlecorepc  so  id  guess  that  it  kind  of  a  thread  synchron  problem  howev  the  strang  thing  is  that  there  actual  noth  to  synchron  as  all  variabl  are  threadloc  realli  look  forward  for  ani  hint  and  just  in  case  you  want  to  confirm  or  falsifi  the  problem  see  the  test  case  below  thank  stephan  ,  formalmethodparamet  stringliter  stringdatatyp  simpleassignmentexpress  stringaddit  objectvari  simplevari  actualmethodparamet  javalangsystemoutprintln  arrayel  addexpress  instancefield  instancefieldinitializationstat  intdatatyp  ifstat  notexpress  objectmethodinvoc  privatemethodspecifi  staticmethodspecifi  forstat  lessexpress  arraylength  postincrementexpress  trycatchstat          