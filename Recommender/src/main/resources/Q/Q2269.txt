 question  ,  result  calc(data  data)  {if  (data.isfinal())  {return  new  result(data);  //  this  is  the  actual  lengthy  calculation}  else  {list<result>  results  =  new  arraylist<result>();for  (int  i=0;  i<data.numofsubtasks();  ++i)  {results.add(calc(data.subtask(i));}return  new  result(results);  //  merge  all  results  in  to  a  single  result}};  executorservice  executorservice  =  executors.newfixedthreadpool(numofthreads);result  calc(data  data)  {if  (data.isfinal())  {return  new  result(data);  //  this  is  the  actual  lengthy  calculation}  else  {list<result>  results  =  new  arraylist<result>();list<callable<void>>  callables  =  new  arraylist<callable<void>>();for  (int  i=0;  i<data.numofsubtasks();  ++i)  {callables.add(new  callable<void>()  {public  void  call()  {  results.add(calc(data.subtask(i));}});}executorservice.invokeall(callables);//  wait  for  all  sub-tasks  to  completereturn  new  result(results);  //  merge  all  results  in  to  a  single  result}}  ,i  have  the  follow  function  in  pseudocod  i  want  to  parallel  it  use  a  fix  number  of  thread  my  first  attempt  was  howev  this  quick  got  stuck  in  a  deadlock  becaus  while  the  top  recurs  level  wait  for  all  thread  to  finish  the  inner  level  also  wait  for  thread  to  becom  avail  how  can  i  effici  parallel  my  program  without  deadlock  ,  formalmethodparamet    