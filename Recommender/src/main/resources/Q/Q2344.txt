 question  ,  import  java.util.list;import  java.util.concurrent.*;public  class  timeoutthreadpoolexecutor  extends  threadpoolexecutor  {private  final  long  timeout;private  final  timeunit  timeoutunit;private  final  scheduledexecutorservice  timeoutexecutor  =  executors.newsinglethreadscheduledexecutor();private  final  concurrentmap<runnable'  '  scheduledfuture>  runningtasks  =  new  concurrenthashmap<runnable'  '  scheduledfuture>();public  timeoutthreadpoolexecutor(int  corepoolsize'  '  int  maximumpoolsize'  '  long  keepalivetime'  '  timeunit  unit'  '  blockingqueue<runnable>  workqueue'  '  long  timeout'  '  timeunit  timeoutunit)  {super(corepoolsize'  '  maximumpoolsize'  '  keepalivetime'  '  unit'  '  workqueue);this.timeout  =  timeout;this.timeoutunit  =  timeoutunit;}public  timeoutthreadpoolexecutor(int  corepoolsize'  '  int  maximumpoolsize'  '  long  keepalivetime'  '  timeunit  unit'  '  blockingqueue<runnable>  workqueue'  '  threadfactory  threadfactory'  '  long  timeout'  '  timeunit  timeoutunit)  {super(corepoolsize'  '  maximumpoolsize'  '  keepalivetime'  '  unit'  '  workqueue'  '  threadfactory);this.timeout  =  timeout;this.timeoutunit  =  timeoutunit;}public  timeoutthreadpoolexecutor(int  corepoolsize'  '  int  maximumpoolsize'  '  long  keepalivetime'  '  timeunit  unit'  '  blockingqueue<runnable>  workqueue'  '  rejectedexecutionhandler  handler'  '  long  timeout'  '  timeunit  timeoutunit)  {super(corepoolsize'  '  maximumpoolsize'  '  keepalivetime'  '  unit'  '  workqueue'  '  handler);this.timeout  =  timeout;this.timeoutunit  =  timeoutunit;}public  timeoutthreadpoolexecutor(int  corepoolsize'  '  int  maximumpoolsize'  '  long  keepalivetime'  '  timeunit  unit'  '  blockingqueue<runnable>  workqueue'  '  threadfactory  threadfactory'  '  rejectedexecutionhandler  handler'  '  long  timeout'  '  timeunit  timeoutunit)  {super(corepoolsize'  '  maximumpoolsize'  '  keepalivetime'  '  unit'  '  workqueue'  '  threadfactory'  '  handler);this.timeout  =  timeout;this.timeoutunit  =  timeoutunit;}@overridepublic  void  shutdown()  {timeoutexecutor.shutdown();super.shutdown();}@overridepublic  list<runnable>  shutdownnow()  {timeoutexecutor.shutdownnow();return  super.shutdownnow();}@overrideprotected  void  beforeexecute(thread  t'  '  runnable  r)  {if(timeout  >  0)  {final  scheduledfuture<?>  scheduled  =  timeoutexecutor.schedule(new  timeouttask(t)'  '  timeout'  '  timeoutunit);runningtasks.put(r'  '  scheduled);}}@overrideprotected  void  afterexecute(runnable  r'  '  throwable  t)  {scheduledfuture  timeouttask  =  runningtasks.remove(r);if(timeouttask  !=  null)  {timeouttask.cancel(false);}}class  timeouttask  implements  runnable  {private  final  thread  thread;public  timeouttask(thread  thread)  {this.thread  =  thread;}@overridepublic  void  run()  {thread.interrupt();}}}  ,im  look  for  an  implement  that  can  be  provid  with  a  timeout  task  that  are  submit  to  the  executorservic  are  interrupt  if  they  take  longer  than  the  timeout  to  run  implement  such  a  beast  isnt  such  a  difficult  task  but  im  wonder  if  anybodi  know  of  an  exist  implement  here  what  i  came  up  with  base  on  some  of  the  discuss  below  ani  comment  ,  intdatatyp  simplevari  longdatatyp  objectvari  simpleassignmentexpress  instancefieldinvoc  thisrefer  formalmethodparamet  objectmethodinvoc  actualmethodparamet  classdefinit  publicclassspecifi  methoddefinit  publicmethodspecifi  voiddatatyp  implementsspecif  methodimplement  privatefieldspecifi  finalfieldspecifi  instancefield  constructordefinit  publicconstructorspecifi    simpleassignmentexpress  genericobjectcreationstat        objectmethodinvoc     