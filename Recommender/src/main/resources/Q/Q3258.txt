 question  ,  "volatile;  n;  volatile  byte[][];  volatile;  atomicintegerarray;  buffers[currentbuffer]  =  buffers[currentbuffer];  //  the  consumer  -  just  an  interface  with  a  process(byte[])  methodaudioinputconsumer  consumer;//  the  audio  data  sourceaudiosource  source;//  the  number  of  buffersint  buffercount;//  controls  the  main  producer  loopvolatile  boolean  isrunning  =  false;//  the  actual  buffersvolatile  byte[][]  buffers;//  the  number  of  buffers  left  to  process.//  shared  counter  -  the  producer  inrements  and  checks  it  has  not  run//  out  of  buffers'  '  while  the  consumer  decremenets  when  it  processes  a  bufferatomicinteger  bufferstoprocess  =  new  atomicinteger(0);//  the  producer  thread.thread  producerthread;//  the  consumer  thread.thread  consumerthread;;  producerthread;  consumerthread;  producerloop;  consumerloop;  producerloop;  atomicinteger;  private  void  producerloop()  {int  buffersize  =  source.getbuffersize();int  currentbuffer  =  0;while  (isrunning)  {if  (bufferstoprocess.get()  ==  buffercount)  {//this  thread  must  be  faster  than  the  processing  thread'  '  we  have  run  out//  of  buffers:  decide  what  to  dosystem.err.println(""warning:  run  out  of  buffers"");}source.read(buffers[currentbuffer]'  '  0'  '  buffersize);  //  read  data  into  the  bufferbuffers[currentbuffer]  =  buffers[currentbuffer];//  self-assignment  to  force  publication  (?)bufferstoprocess.incrementandget();  //  signal  to  the  other  thread  that  there  is  data  to  readcurrentbuffer  =  (currentbuffer  +  1)  %  buffercount;//  next  buffer}};  consumerloop;  atomicinteger;  bufferstoprocess;  bufferstoprocess;  private  void  consumerloop()  {int  currentbuffer  =  0;while  (isrunning)  {if  (bufferstoprocess.get()  >  0)  {consumer.process(buffers[currentbuffer]);//  process  the  databufferstoprocess.decrementandget();//  signal  that  we  are  done  with  this  buffercurrentbuffer  =  (currentbuffer  +  1)  %  buffercount;  //  next  buffer}thread.yield();}}"  ,im  write  an  audio  dsp  applic  and  ive  opt  to  use  a  producerconsum  model  been  read  a  lot  about  and  other  thread  issu  but  ive  got  a  coupl  of  question  about  some  specif  of  my  case  particular  one  of  the  thing  i  need  to  be  share  between  thread  is  an  array  of  array  i  have  a  class  which  repres  the  producerto  allow  for  variat  in  process  time  the  produc  store  buffer  which  it  will  fill  in  rotat  everi  time  more  audio  data  is  avail  and  pass  the  buffer  on  to  the  consum  thread  ill  start  with  my  question  and  then  ill  tri  to  explain  my  system  in  enough  detail  sorri  for  the  long  post  thank  for  bear  with  meid  also  be  veri  grate  for  general  comment  about  my  implement  and  it  thread  safeti  my  buffer  are  repres  by  a  arrayi  am  well  awar  that  the  onli  make  the  volatil  but  have  read  around  so  and  various  blog  post  it  seem  that  i  have  two  option  i  could  usebut  if  i  understand  correct  eg  a  self  assign  which  in  my  case  is  will  ensur  public  which  you  will  see  in  my  code  below  ill  tri  to  overview  the  produc  class  briefli  these  are  the  instanc  variabl  onc  i  start  the  and  they  just  execut  the  method  and  respectivelyblock  while  wait  for  audio  data  read  into  the  buffer  then  use  the  instanc  to  signal  to  the  consum  loopwait  until  the  is  greater  than  zero  then  call  the  consum  object  to  do  whatev  it  want  with  the  dataafterward  is  decrement  and  we  wait  for  it  to  becom  nonzero  again  mani  thank  ,  simpleassignmentexpress       