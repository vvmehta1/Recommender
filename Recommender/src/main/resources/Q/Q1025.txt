 question  ,  "arraylists;  filtertitle;  filterartist;  filterrank;  filteryear;  song2  arraylist;  [];  arraylist;  filterrank;  filteryear;  public  void  sortyear()  {  collections.sort(songs2'  '  songcomparator.byyear());  //  now  we  have  a  sorted  list  system.out.println(songs2);};  public  void  filterartist(string  s)  {  int  n  =  0;  if  (n  ==  0)  {system.out.println(""program  is  processing."");n++;for  (song  song1  :  songs2)  {  if  ((!(((song1.artist).contains(s)))))  {itemstoremove.add(song1);  }}songs2.removeall(itemstoremove);itemstoremove.clear();  }  system.out.println(songs2);};  public  void  filterrank(range  r)  {  int  n  =  0;  if  (n  ==  0)  {system.out.println(""program  is  processing."");n++;for  (song  song1  :  songs2)  {  if  (song1.rank  >  (r.getmax())  ||  (song1.rank)  <  (r.getmin()))  {itemstoremove.add(song1);  }}songs2.removeall(itemstoremove);itemstoremove.clear();  }  system.out.println(songs2);};  while  (input.hasnextline())  {  int  n  =  0;  songcollection  collection  =  new  songcollection(songs);  string  inputtype  =  input.nextline();  string  delims  =  ""[  ]"";  string[]  tokens  =  inputtype.split(delims);  for  (int  i  =  0;  i  <  tokens.length;  i++)  {n  =  0;if  (n  ==  0)  {  if  ((tokens[i]).contains(""year:""))  {collection.filteryear(range.parse(tokens[i]));n  =  1;  }//  end  of  year  loop  if  ((tokens[i]).contains(""rank:""))  {collection.filterrank(range.parse(tokens[i]));n  =  1;  }//  end  of  rank  if  ((tokens[i]).contains(""artist:""))  {collection.filterartist(tokens[i]);n  =  1;  }//  end  of  artist  if  ((tokens[i]).contains(""title:""))  {collection.filtertitle(tokens[i]);n  =  1;  }//  end  of  title  if  ((tokens[i]).contains(""sort:""))  {  if  ((tokens[i]).contains(""title""))  {collection.sorttitle();n  =  1;  }//  end  of  sort  title  if  ((tokens[i]).contains(""artist""))  {collection.sortartist();n  =  1;  }//  end  of  sort  artist  if  ((tokens[i]).contains(""rank""))  {collection.sortrank();n  =  1;  }//  end  of  sort  rank  if  ((tokens[i]).contains(""year""))  {collection.sortyear();n  =  1;  }//  end  of  sort  year  }//end  of  sort}//  end  of  for  loop  }//  end  of  input.hasnextline  loop  final  printstream  console  =  system.out;  //saves  original  system.out  file  outputfile  =  new  file(""output.txt"");  //output  file  printstream  out  =  new  printstream(new  fileoutputstream(outputfile));  //new  fileoutputstream  system.setout(out);  //changes  where  data  will  be  printed  system.out.println(collection.tostring());  system.setout(console);  //changes  output  to  print  back  to  console  scanner  outputfilescanner  =  new  scanner(outputfile);  //inputs  data  from  file  while  ((outputfilescanner.hasnextline()))  {  //while  the  file  still  has  datasystem.out.println(outputfilescanner.nextline());  //print  }  outputfilescanner.close();  out.close();};import  java.io.*;  import  java.io.file;  import  java.io.filenotfoundexception;  import  java.util.*;  import  java.util.comparator;  import  java.util.scanner;  import  java.util.stringtokenizer;public  class  gazillionsongs  {  public  static  void  main(string[]  args)  throws  filenotfoundexception'  '  ioexception  {system.out.println(""welcome  to  java  song  collection!"");  //  greets  the  usersystem.out.println(""this  program  sorts  and  filters  large  databases  of  popular  songs."");  //  explains  purpose  of  programsystem.out.println(""this  program  is  able  to  filter  and  sort  by  year'  '  artist'  '  title  and  rank."");system.out.println(""please  enter  a  file  that  contains  a  database  you  wish  to  filter  or  sort.  (i.e'  '  alistofsongs.txt)"");  //  sample  file  =  agazillionsongs.txtscanner  fileinput  =  new  scanner(system.in);  //scanner  which  accepts  filenamestring  filename  =  fileinput.nextline();file  f  =  new  file(filename);  //creates  file  from  input/*error  check  for  file  here*/scanner  filescanner  =  new  scanner(f);  //inputs  data  from  filearraylist<song>  songs  =  new  arraylist<song>();while  ((filescanner.hasnextline()))  {  songs.add(song.parse(filescanner.nextline()));}system.out.println(""please  select  which  commands  you  would  like  to  use  for  the  program."");system.out.println(""please  format  your  command  like  the  following  example:  year:<year(s)>  rank:<rank(s)>  artist:<artist>  title:<title>  sortby:<field>"");system.out.println();system.out.println(""you  may  pick  any  number  of  commands  you  want."");system.out.println(""for  years  and  rank'  '  you  may  select  a  range  of  years  or  ranks."");system.out.println(""for  artists  and  titles'  '  you  may  enter  a  partial  name  or  title."");system.out.println(""i.e'  '  year:1983  rank:1"");scanner  input  =  new  scanner(system.in);while  (input.hasnextline())  {  int  n  =  0;  songcollection  collection  =  new  songcollection(songs);  string  inputtype  =  input.nextline();  string  delims  =  ""[  ]"";  string[]  tokens  =  inputtype.split(delims);  for  (int  i  =  0;  i  <  tokens.length;  i++)  {n  =  0;if  (n  ==  0)  {  if  ((tokens[i]).contains(""year:""))  {collection.filteryear(range.parse(tokens[i]));n  =  1;  }//  end  of  year  loop  if  ((tokens[i]).contains(""rank:""))  {collection.filterrank(range.parse(tokens[i]));n  =  1;  }//  end  of  rank  if  ((tokens[i]).contains(""artist:""))  {collection.filterartist(tokens[i]);n  =  1;  }//  end  of  artist  if  ((tokens[i]).contains(""title:""))  {collection.filtertitle(tokens[i]);n  =  1;  }//  end  of  title  if  ((tokens[i]).contains(""sort:""))  {  if  ((tokens[i]).contains(""title""))  {collection.sorttitle();n  =  1;  }//  end  of  sort  title  if  ((tokens[i]).contains(""artist""))  {collection.sortartist();n  =  1;  }//  end  of  sort  artist  if  ((tokens[i]).contains(""rank""))  {collection.sortrank();n  =  1;  }//  end  of  sort  rank  if  ((tokens[i]).contains(""year""))  {collection.sortyear();n  =  1;  }//  end  of  sort  year  }//end  of  sort}//  end  of  for  loop  }//  end  of  input.hasnextline  loop  final  printstream  console  =  system.out;  //saves  original  system.out  file  outputfile  =  new  file(""output.txt"");  //output  file  printstream  out  =  new  printstream(new  fileoutputstream(outputfile));  //new  fileoutputstream  system.setout(out);  //changes  where  data  will  be  printed  system.out.println(collection.tostring());  system.setout(console);  //changes  output  to  print  back  to  console  scanner  outputfilescanner  =  new  scanner(outputfile);  //inputs  data  from  file  while  ((outputfilescanner.hasnextline()))  {  //while  the  file  still  has  datasystem.out.println(outputfilescanner.nextline());  //print  }  outputfilescanner.close();  out.close();}  }//  end  of  main}//  end  of  classclass  song{  public  enum  order  {year'  '  rank'  '  title'  '  artist}  public  int  year;  public  int  rank;  public  string  artist;  public  string  title;  public  static  song  parse(string  s)  {song  instance  =  new  song();stringtokenizer  tokenizer  =  new  stringtokenizer(s'  '  ""  "");instance.year  =  integer.parseint(tokenizer.nexttoken());instance.rank  =  integer.parseint(tokenizer.nexttoken());instance.artist  =  (tokenizer.nexttoken());instance.title  =  (tokenizer.nexttoken());return  instance;  }  public  int  getyear()  {return  year;  }  public  int  getrank()  {return  rank;  }  public  string  getartist()  {return  artist;  }  public  string  gettitle()  {return  title;  }  public  string  tostring()  {string  output  =  ""year  =  ""  +  year  +  ""rank  =  ""  +  rank  +  ""artist  =  ""+  artist  +  ""title  =  ""  +  title;return  output;  }}class  range  {  private  int  min;  private  int  max;  public  range()  {system.out.println(""please  wait."");  }  public  static  range  parse(string  s)  {range  instance  =  new  range();  //  instance  is  created  here  so  object//  variables  may  be  accessedstring  field;  //  string  to  contain  deleted  part  of  user  inputstringtokenizer  tokenizer  =  new  stringtokenizer(s'  '  ""-"");stringtokenizer  tokenizer2  =  new  stringtokenizer(s'  '  "":"");//  for  separating  ""field:""  from  the  //  other  part  of  the  stringif  (s.contains("":""))  {  //  this  deletes  the  ""field:""  of  the  user  input  so//  it  does  not  interfere  with  the  parsing  field  =  (tokenizer2.nexttoken());  s  =  s.replace(field'  '  """");  s  =  s.replace("":""'  '  """");}if  (s.contains(""-""))  {  instance.min  =  integer.parseint(tokenizer.nexttoken());  instance.max  =  integer.parseint(tokenizer.nexttoken());}  else  if  (!(s.contains(""-"")))  {  {instance.min  =  integer.parseint(s);instance.max  =  integer.parseint(s);  }}system.out.println(""range  max  =  ""  +  instance.max);system.out.println(""range  min  =  ""  +  instance.min);return  instance;  }  public  boolean  contains(int  n)  {if  (n  >  min  &&  n  <  max)  {  //if  the  number  is  contained  in  the  range'  '  method  returns  true.  return  true;}  else  if  (n  ==  min  &&  n  ==  max)  {  return  true;}  else  {  return  false;}  }  public  int  getmin()  {return  min;  }  public  int  getmax()  {return  max;  }}class  songcollection  {  arraylist<song>  songs2;  arraylist<song>  itemstoremove  =  new  arraylist<song>();  //  second  collection  //  for  items  to  //  remove  public  songcollection(arraylist<song>  songs)  {  //  constructor  for  songcollectionsystem.out.println(""test"");this.songs2  =  songs;}  public  void  filteryear(range  r)  {int  n  =  0;if  (n  ==  0)  {  system.out.println(""program  is  processing."");  n++;  for  (song  song1  :  songs2)  {if  (song1.year  >  (r.getmax())  ||  (song1.year)  <  (r.getmin()))  {  itemstoremove.add(song1);}  }  songs2.removeall(itemstoremove);  itemstoremove.clear();}system.out.println(songs2);  }  public  void  filterrank(range  r)  {int  n  =  0;if  (n  ==  0)  {  system.out.println(""program  is  processing."");  n++;  for  (song  song1  :  songs2)  {if  (song1.rank  >  (r.getmax())  ||  (song1.rank)  <  (r.getmin()))  {  itemstoremove.add(song1);}  }  songs2.removeall(itemstoremove);  itemstoremove.clear();}system.out.println(songs2);  }  public  void  filterartist(string  s)  {int  n  =  0;if  (n  ==  0)  {  system.out.println(""program  is  processing."");  n++;  for  (song  song1  :  songs2)  {if  ((!(((song1.artist).contains(s)))))  {  itemstoremove.add(song1);}  }  songs2.removeall(itemstoremove);  itemstoremove.clear();}system.out.println(songs2);  }  public  void  filtertitle(string  s)  {int  n  =  0;if  (n  ==  0)  {  system.out.println(""program  is  processing."");  n++;  for  (song  song1  :  songs2)  {if  ((!(((song1.title).contains(s)))))  {itemstoremove.add(song1);}  }  songs2.removeall(itemstoremove);  itemstoremove.clear();}system.out.println(songs2);  }  public  void  sorttitle()  {collections.sort(songs2'  '  songcomparator.bytitle());  //  now  we  have  a  sorted  listsystem.out.println(songs2);}  public  void  sortrank()  {collections.sort(songs2'  '  songcomparator.byrank());  //  now  we  have  a  sorted  listsystem.out.println(songs2);}  public  void  sortartist()  {collections.sort(songs2'  '  songcomparator.byartist());  //  now  we  have  a  sorted  listsystem.out.println(songs2);}  public  void  sortyear()  {collections.sort(songs2'  '  songcomparator.byyear());  //  now  we  have  a  sorted  listsystem.out.println(songs2);}  public  string  tostring()  {string  result  =  """";for  (int  i  =  0;  i  <  songs2.size();  i++)  {  result  +=  ""  ""  +  songs2.get(i);}return  result;  }}class  songcomparator  implements  comparator<song>  {  public  enum  order{year_sort'  '  rank_sort'  '  artist_sort'  '  title_sort  }  private  order  sortingby;  public  songcomparator(order  sortingby){this.sortingby  =  sortingby;  }  public  static  songcomparator  bytitle()  {  return  new  songcomparator(songcomparator.order.title_sort);  }  public  static  songcomparator  byyear()  {  return  new  songcomparator(songcomparator.order.year_sort);  }  public  static  songcomparator  byartist()  {  return  new  songcomparator(songcomparator.order.artist_sort);  }  public  static  songcomparator  byrank()  {  return  new  songcomparator(songcomparator.order.rank_sort);  }  @override  public  int  compare(song  song1'  '  song  song2)  {switch  (sortingby)  {case  year_sort:  return  integer.compare(song1.year'  '  song2.year);case  rank_sort:  return  integer.compare(song1.rank'  '  song2.rank);case  artist_sort:  return  song1.artist.compareto(song2.artist);case  title_sort:  return  song1.title.compareto(song2.title);}throw  new  runtimeexception(""practically  unreachable  code'  '  can't  be  thrown"");  }}"  ,follow  up  question  herefor  some  reason  it  take  an  extraordinari  amount  of  time  for  the  to  be  print  to  the  output  file  usual  minut  howev  this  onli  happen  with  the  sort  method  or  the  or  method  method  that  concern  string  inputswhen  i  run  or  it  run  perfect  fine  when  i  print  the  direct  from  the  filter  method  the  onli  thing  that  is  print  is  which  mean  the  is  empti  but  it  shouldnt  be  and  the  and  method  still  work  regardless  of  thissomehow  i  think  it  relat  though  input  file  can  be  found  hereexampl  sort  method  exampl  filter  method  for  string  exampl  filter  method  for  int  code  in  main  class  for  printingoutput  file  full  code  for  compil  ,  simpleassignmentexpress  objectvari  simplevari  actualmethodparamet  stringliter  stringdatatyp  javalangsystemoutprintln  publicfieldspecifi  instancefield  intdatatyp  stringvari  formalmethodparamet  staticmethodspecifi  objectcreationstat  constructorcal  privatefieldspecifi  constructordefinit  publicconstructorspecifi  javalangstringreplac  objectmethodinvoc  javalangintegerparseint  instancefieldinitializationstat  stringaddit  constantinvoc  booleandatatyp  javautilarraylist  genericobjectcreationstat  instancefieldinvoc  thisrefer  returnstat 