 question  ,  "commportidentifier  portidentifier  =  commportidentifier.getportidentifier(port);commport  comm  =  portidentifier.open(""whatever""'  '  2000);serialport  serial  =  (serialport)comm;...settingsthread  t  =  new  thread(new  serialreader(serial.getinputstream()));t.start();;  public  void  run()  {readablebytechannel  bytechan  =  channels.newchannel(in);  //in  =  inputstream  passed  to  serialreaderbytebuffer  buffer  =  bytebuffer.allocate(100);while  (true)  {try  {bytechan.read(buffer);}  catch  (exception  e)  {system.out.println(e);}}};  public  void  stop()  {t.interrupt();serial.close();}"  ,im  use  rxtx  to  read  data  from  a  serial  portth  read  is  done  within  a  thread  spawn  in  the  follow  manner  the  serialread  class  implement  runnabl  and  just  loop  indefinit  read  from  the  port  and  construct  the  data  into  use  packag  befor  send  it  off  to  other  applicationshowev  ive  reduc  it  down  to  the  follow  simplic  when  a  user  click  a  stop  button  the  follow  function  fire  that  should  in  theori  close  the  input  stream  and  break  out  of  the  block  bytechanreadbuff  callth  code  is  as  follow  howev  when  i  run  this  code  i  never  get  a  closedbyinterruptexcept  which  should  fire  onc  the  input  stream  closesfurthermor  the  execut  block  on  the  call  to  serialclos  becaus  the  under  input  stream  is  still  block  on  the  read  calliv  tri  replac  the  interrupt  call  with  bytechanclos  which  should  then  caus  an  asynchronouscloseexcept  howev  im  get  the  same  result  ani  help  on  what  im  miss  would  be  great  appreci  ,    classdefinit  privateclassspecifi  staticclassspecifi     simpleassignmentexpress  