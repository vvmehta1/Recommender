 question  ,  "synchronized;  import  java.util.concurrent.locks.reentrantlock;public  class  synchronizedperformance  {static  class  counter  {private  static  final  int  max  =  1  <<  24;int  count;long  lastlog  =  0;private  final  reentrantlock  lock  =  new  reentrantlock();private  int  incrementandget()  {count++;if  (count  ==  max)  {long  now  =  system.nanotime();if  (lastlog  !=  0)  {long  elapsedtime  =  now  -  lastlog;system.out.printf(""counting  took  %.2f  ns""'  '  double.valueof((double)elapsedtime  /  max));}lastlog  =  now;count  =  0;}return  count;}synchronized  int  synchronizedincrementandget()  {return  incrementandget();}int  lockedincrementandget()  {lock.lock();try  {return  incrementandget();}  finally  {lock.unlock();}}}static  class  synchronizedcounteraccessor  implements  runnable  {private  final  counter  counter;public  synchronizedcounteraccessor(counter  counter)  {this.counter  =  counter;}@overridepublic  void  run()  {while  (true)counter.synchronizedincrementandget();}}static  class  lockedcounteraccessor  implements  runnable  {private  final  counter  counter;public  lockedcounteraccessor(counter  counter)  {this.counter  =  counter;}@overridepublic  void  run()  {while  (true)counter.lockedincrementandget();}}public  static  void  main(string[]  args)  {counter  counter  =  new  counter();final  int  n  =  integer.parseint(args[0]);final  string  mode  =  args[1];if  (mode.equals(""locked""))  {for  (int  i  =  0;  i  <  n;  i++)new  thread(new  lockedcounteraccessor(counter)'  '  ""ca""  +  i).start();}  else  if  (mode.equals(""synchronized""))  {for  (int  i  =  0;  i  <  n;  i++)new  thread(new  synchronizedcounteraccessor(counter)'  '  ""ca""  +  i).start();}  else  {throw  new  illegalargumentexception(""locked|synchronized"");}}};  java  synchronizedperformance  1  synchronized;  java  synchronizedperformance  2  synchronized;  java  synchronizedperformance  2  synchronized"  ,i  want  to  understand  perform  in  multithread  environ  for  that  i  have  written  a  small  test  that  i  ran  on  my  machin  quadcor  intel  window  xp  sun  jdk  with  surpris  result  the  test  is  basic  a  threadsaf  counter  that  is  synchron  use  either  the  keyword  or  an  explicit  lock  here  is  the  code  i  made  the  follow  observ  i  dont  understand  the  third  observ  what  plausibl  explan  exist  for  this  phenomenon  ,  staticclassspecifi  implementsspecif  methodimplement  privatefieldspecifi  finalfieldspecifi  instancefield  simplevari  formalmethodparamet  constructordefinit  publicconstructorspecifi  instancefieldinvoc  thisrefer  simpleassignmentexpress  stringliter  stringdatatyp  stringaddit  objectmethodinvoc  intdatatyp  forstat  lessexpress  postincrementexpress  objectcreationstat  constructorcal  actualmethodparamet  throwstat  orexpress    