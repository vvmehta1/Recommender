 question  ,  "import  java.util.hashset;public  class  instrumentedhashset<e>  extends  hashset<e>  {//  the  number  of  attempted  element  insertionsprivate  int  addcount  =  0;public  instrumentedhashset()  {}public  instrumentedhashset(int  initcap'  '  float  loadfactor)  {super(initcap'  '  loadfactor);}@overridepublic  boolean  add(e  e)  {addcount++;return  super.add(e);}@overridepublic  boolean  addall(collection<?  extends  e>  c)  {addcount  +=  c.size();return  super.addall(c);}public  int  getaddcount()  {return  addcount;}public  static  void  main(string[]  args)  {instrumentedhashset<string>  s  =  new  instrumentedhashset<string>();s.addall(arrays.aslist(""snap""'  '  ""crackle""'  '  ""pop""));system.out.println(s.getaddcount());}}  ;  public  class  forwardingset<e>  implements  set<e>  {private  final  set<e>  s;public  forwardingset(set<e>  s)  {this.s  =  s;}public  void  clear()  {s.clear();}public  boolean  contains(object  o)  {return  s.contains(o);}public  boolean  isempty()  {return  s.isempty();}public  int  size()  {return  s.size();}public  iterator<e>  iterator()  {return  s.iterator();}public  boolean  add(e  e)  {return  s.add(e);}public  boolean  remove(object  o)  {return  s.remove(o);}public  boolean  containsall(collection<?>  c)  {return  s.containsall(c);}public  boolean  addall(collection<?  extends  e>  c)  {return  s.addall(c);}public  boolean  removeall(collection<?>  c)  {return  s.removeall(c);}public  boolean  retainall(collection<?>  c)  {return  s.retainall(c);}public  object[]  toarray()  {return  s.toarray();}public  <t>  t[]  toarray(t[]  a)  {return  s.toarray(a);}@overridepublic  boolean  equals(object  o)  {return  s.equals(o);}@overridepublic  int  hashcode()  {return  s.hashcode();}@overridepublic  string  tostring()  {return  s.tostring();}};  import  java.util.*;public  class  instrumentedset<e>  extends  forwardingset<e>  {private  int  addcount  =  0;public  instrumentedset(set<e>  s)  {super(s);}@overridepublic  boolean  add(e  e)  {addcount++;return  super.add(e);}@overridepublic  boolean  addall(collection<?  extends  e>  c)  {addcount  +=  c.size();return  super.addall(c);}public  int  getaddcount()  {return  addcount;}public  static  void  main(string[]  args)  {instrumentedset<string>  s  =  new  instrumentedset<string>(new  hashset<string>());s.addall(arrays.aslist(""snap""'  '  ""crackle""'  '  ""pop""));system.out.println(s.getaddcount());}}"  ,i  am  read  the  book  effect  java  by  joshua  bloch  on  the  item  of  favor  composit  over  inherit  he  give  an  exampl  of  use  hashset  and  queri  how  mani  element  have  been  ad  sinc  it  was  creatednot  to  be  confus  with  current  size  which  goe  down  when  an  element  is  remov  he  provid  the  follow  code  and  here  the  getaddcount  return  which  i  can  understand  this  should  return  actual  this  is  becaus  hashset  addal  method  is  implement  on  top  of  it  add  method  now  he  explain  a  way  to  fix  this  use  wrapper  class  composit  and  forward  here  is  where  i  am  havinghard  time  to  understandh  provid  the  follow  two  class  andhow  this  work  in  the  main  method  i  creat  an  instanc  of  hashset  and  use  addal  method  i  add  all  the  element  of  list  but  the  hashset  invok  it  addal  method  which  in  turn  use  it  add  method  which  should  be  the  same  as  in  the  first  in  correct  exampl  and  i  should  get  valu  of  howev  this  give  me  ,  floatdatatyp  simplevari  formalmethodparamet  importstat  ondemandimport  implementsspecif  methodimplement  privatefieldspecifi  finalfieldspecifi  instancefield  constructordefinit  publicconstructorspecifi  instancefieldinvoc  thisrefer  simpleassignmentexpress  objectmethodinvoc  booleandatatyp  javalangobject  returnstat  actualmethodparamet  intdatatyp  javalangsystemoutprintln    