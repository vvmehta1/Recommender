 question  ,  clone;  bar();  return;  bar;  isitsafe;  bar;  isitsafe;  public  class  isitsafe  implements  cloneable  {private  int  foo;private  int  bar;public  isitsafe  foo(int  foo)  {isitsafe  clone  =  clone();clone.foo  =  foo;return  clone;}public  isitsafe  bar(int  bar)  {isitsafe  clone  =  clone();clone.bar  =  bar;return  clone;}public  int  getfoo()  {return  foo;}public  int  getbar()  {return  bar;}protected  isitsafe  clone()  {try  {return  (isitsafe)  super.clone();}  catch  (clonenotsupportedexception  e)  {throw  new  error(e);}}}  ,i  repli  to  a  earlier  about  thread  safeti  which  did  not  get  a  definit  answer  i  think  so  i  have  been  tri  to  convinc  myself  that  the  design  is  broken  visibl  by  have  thousand  of  thread  read  and  write  that  object  but  i  have  not  been  abl  to  get  anyth  unexpect  that  is  obvious  not  a  proof  that  it  is  thread  safe  probabl  mere  a  proof  of  my  own  limit  i  understand  the  risk  of  reorder  but  i  dont  see  how  it  could  appli  in  that  case  in  the  sens  that  the  instanc  in  the  method  is  local  and  the  chang  on  it  field  is  done  befor  be  releas  to  the  outsid  world  with  after  which  the  instanc  is  effect  immut  so  a  thread  look  at  the  return  object  would  see  it  with  it  field  alreadi  set  to  the  correct  valuecould  you  show  a  piec  of  code  that  use  and  that  could  lead  thread  to  see  differ  valu  of  the  field  of  a  given  instanc  of  for  refer  and  eas  of  read  i  copi  the  code  here  ,  classdefinit  publicclassspecifi  implementsspecif  methodimplement  privatefieldspecifi  instancefield  intdatatyp  simplevari  formalmethodparamet  methoddefinit  publicmethodspecifi  simpleassignmentexpress  returnstat  protectedmethodspecifi  trycatchstat  explicittypecast  throwstat  objectcreationstat  constructorcal  actualmethodparamet       