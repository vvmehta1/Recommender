 question  ,  "import  java.lang.management.managementfactory;import  java.lang.management.memorypoolmxbean;import  java.lang.management.memoryusage;import  java.lang.management.threadmxbean;import  java.util.list;public  class  demo1  {public  static  void  main(string  arg[])  {demo1  demo  =  new  demo1();thread  t5=  new  thread(new  runnable()  {  public  void  run()  {int  count=0;//  thread.state;//  system.out.println(""clientmsgreceiver  started-----"");demo1.childdemoobj  =  new  demo1.childdemo();while(true)  {//  system.out.println(""threadcount  is""+thread);//  system.out.println(""count  is""+(count++));thread  t=new  thread(obj);t.start();threadmxbean  tb  =  managementfactory.getthreadmxbean();list<memorypoolmxbean>  pools  =  managementfactory.getmemorypoolmxbeans();for  (memorypoolmxbean  pool  :  pools)  {  memoryusage  peak  =  pool.getpeakusage();  system.out.format(""peak  %s  memory  used:  %'  'd%n""'  '  pool.getname()'  '  peak.getused());  system.out.format(""peak  %s  memory  reserved:  %'  'd%n""'  '  pool.getname()'  '  peak.getcommitted());}  system.out.println(""current  thread  count""+  tb.getthreadcount());system.out.println(""peak  thread  count""+  tb.getpeakthreadcount());system.out.println(""current_thread_cpu_time  ""  +  tb.getcurrentthreadcputime());system.out.println(""daemon  thread  count""  +tb.getdaemonthreadcount());  }  //  chatlogin  =  new  chatlogin();  }});t5.start();}static  class  childdemo  implements  runnable  {  public  void  run()  {try  {//system.out.println(""thread  started  with  custom  run  method"");thread.sleep(100000);}  catch  (interruptedexception  e)  {//  todo  auto-generated  catch  blocke.printstacktrace();}finally  {system.out.println(""a""  +thread.activecount());}}}};  import  java.lang.management.managementfactory;import  java.lang.management.memorypoolmxbean;import  java.lang.management.memoryusage;import  java.lang.management.threadmxbean;import  java.util.list;import  java.util.concurrent.arrayblockingqueue;import  java.util.concurrent.blockingqueue;import  java.util.concurrent.threadpoolexecutor;import  java.util.concurrent.timeunit;public  class  executor_demo  {public  static  void  main(string  arg[])  {  blockingqueue<runnable>  queue  =  new  arrayblockingqueue<runnable>(10);  threadpoolexecutor  executor  =  new  threadpoolexecutor(10'  '  100'  '  10'  '  timeunit.microseconds'  '  queue);  executor_demo  demo  =  new  executor_demo();  executor.execute(new  runnable()  {  public  void  run()  {int  count=0;//  system.out.println(""clientmsgreceiver  started-----"");executor_demo.demo  demo2  =  new  executor_demo.demo();blockingqueue<runnable>  queue1  =  new  arrayblockingqueue<runnable>(1000);threadpoolexecutor  executor1  =  new  threadpoolexecutor(1000'  '  10000'  '  10'  '  timeunit.microseconds'  '  queue1);while(true)  {  //  system.out.println(""threadcount  is""+thread);  //  system.out.println(""count  is""+(count++));  runnable  command=  new  demo();  //  executor1.execute(command);  executor1.submit(command);  //  thread  t=new  thread(demo2);  //  t.start();  threadmxbean  tb  =  managementfactory.getthreadmxbean();  /*  try  {executor1.awaittermination(100'  '  timeunit.microseconds);}  catch  (interruptedexception  e)  {  //  todo  auto-generated  catch  block  e.printstacktrace();}  */list<memorypoolmxbean>  pools  =  managementfactory.getmemorypoolmxbeans();for  (memorypoolmxbean  pool  :  pools)  {  memoryusage  peak  =  pool.getpeakusage();  system.out.format(""peak  %s  memory  used:  %'  'd%n""'  'pool.getname()'  '  peak.getused());  system.out.format(""peak  %s  memory  reserved:  %'  'd%n""'  'pool.getname()'  '  peak.getcommitted());}system.out.println(""daemon  threads""+tb.getdaemonthreadcount());system.out.println(""all  threads""+tb.getallthreadids());system.out.println(""current  thread  cpu  time  ""  +  tb.getcurrentthreadcputime());system.out.println(""current  thread  user  time  ""  +  tb.getcurrentthreadusertime());system.out.println(""total  started  thread  count  ""  +  tb.gettotalstartedthreadcount());system.out.println(""current  thread  count""+  tb.getthreadcount());system.out.println(""peak  thread  count""+  tb.getpeakthreadcount());system.out.println(""current_thread_cpu_time  ""  +  tb.getcurrentthreadcputime());system.out.println(""daemon  thread  count""  +  tb.getdaemonthreadcount());//  executor1.shutdown();}//chatlogin  =  new  chatlogin();}  });  executor.shutdown();}static  class  demo  implements  runnable  {public  void  run()  {try  {//  system.out.println(""thread  started  with  custom  run  method"");thread.sleep(100000);}  catch  (interruptedexception  e)  {//  todo  auto-generated  catch  blocke.printstacktrace();}finally  {  system.out.println(""a""  +thread.activecount());}  }}}"  ,i  am  tri  to  find  out  about  the  perform  differ  between  normal  multithread  and  multithread  use  executor  to  maintain  a  thread  pool  the  below  are  code  exampl  for  both  sampl  outputwhen  i  run  both  program  it  turn  out  the  executor  is  more  expens  than  normal  multithread  whi  is  this  so  and  given  this  what  is  the  use  of  executor  exact  we  use  the  executor  to  manag  thread  pool  i  would  have  expect  the  executor  to  give  better  result  than  normal  multithread  basic  im  do  this  as  i  need  to  handl  million  of  client  use  socket  program  with  multithread  ani  suggest  will  be  help  ,  objectmethodinvoc  instancefield  simplevari  simpleassignmentexpress    