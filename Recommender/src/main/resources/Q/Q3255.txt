 question  ,  "private  final  reentrantlock  lock  =  new  reentrantlock();private  final  condition  producers  =  lock.newcondition();private  final  condition  consumers  =  lock.newcondition();@overridepublic  void  run()  {while  (true)  {try  {//lock.lockinterruptibly();try  {while  (sharedresource.isempty())  {printerr(name  +  ""  :  queue  empty  .."");consumers.await(500'  '  timeunit.milliseconds);}string  obj  =  sharedresource.remove(0);printout(name  +  ""  :  ""  +  obj);if  (obj.equals(poison_pill))  {sharedresource.add(poison_pill);//  system.err.println(name  +""  taking  break"");break;}producers.signal();}  finally  {lock.unlock();}thread.sleep(100);}  catch  (interruptedexception  e)  {e.printstacktrace();}//  if(debug)system.err.println(""consumer  looping"");}};  if  the  current  thread  is  not  the  holder  of  this  lock  then  illegalmonitorstateexception  is  thrown"  ,where  am  i  go  wrong  even  though  my  consum  thread  is  not  hold  the  lock  the  program  is  not  throw  illegalmonitorstateexcept  for  ani  of  the  lock  call  unlockawaitsign  void  javautilconcurrentlocksreentrantlockunlock  as  per  java  public  void  unlockattempt  to  releas  this  lockif  the  current  thread  is  the  holder  of  this  lock  then  the  hold  count  is  decrement  if  the  hold  count  is  now  zero  then  the  lock  is  releas  ,  objectmethodinvoc  stringvari  stringdatatyp  instancefield  instancefieldinitializationstat  simpleassignmentexpress  actualmethodparamet 