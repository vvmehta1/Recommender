 question  ,  int  count=0;for(int  i=3;i<=100;i++){for(int  j=2;j<i;j++){if(i%j==0)count=count+1;}if(count>0)system.out.println(i);count=0;};  public  class  comp  extends  thread{int  start'  'last;public  comp(int  start'  'int  last){this.start=start;this.last=last;}public  void  run(){int  count=0;for(int  i=start;i<=last;i++){for(int  j=i-1;j>=2;j--){if(i%j==0)count=count+1;}if(count>0)system.out.println(i);count=0;}}public  static  void  main(string[]  args)  {comp  c1=new  comp(3'  '50);comp  c2=new  comp(51'  '100);c1.start();try{c1.join();}catch(exception  e){}c2.start();}}  ,in  an  interview  i  was  ask  to  print  composit  nos  bw  to  i  did  it  then  she  ask  me  to  do  it  use  two  thread  as  i  know  run  cant  take  argument  and  we  dont  use  two  thread  for  atom  oper  is  it  possibl  to  use  two  thread  for  this  oper  base  on  jigar  suggest  i  wrote  it  like  this  is  it  correct  way  of  do  it  to  get  the  number  in  sequenc  ,  intdatatyp  simplevari  instancefieldinvoc  thisrefer  simpleassignmentexpress  forstat  nestedforloop  lessequalexpress  postincrementexpress  subtractexpress  greaterequalexpress  postdecrementexpress  ifstat  modulusexpress  equalexpress  addexpress  greaterexpress  javalangsystemoutprintln  actualmethodparamet  formalmethodparamet  staticmethodspecifi  objectcreationstat  constructorcal  objectmethodinvoc  trycatchstat    ifstat  greaterexpress  javalangsystemoutprintln  actualmethodparamet        extendsspecif  privatefieldspecifi  instancefield  intdatatyp  simplevari  formalmethodparamet  constructordefinit  publicconstructorspecifi  javalanginteg  simpleassignmentexpress  objectcreationstat  constructorcal  actualmethodparamet  instancefieldinitializationstat  staticmethodspecifi  objectmethodinvoc  staticfieldspecifi  classfield  objectvari  instancefieldinvoc  thisrefer  protectedmethodspecifi  subtractexpress  divideexpress  ifstat  greaterexpress  returnstat  javalangsystemoutprintln  stringliter  stringdatatyp  