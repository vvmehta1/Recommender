 question  ,  "package  hitesh;/**  *  *  @author  jhamb  */public  class  testthreadpool  {  public  static  void  main(string  args[])  throws  interruptedexception  {threadpool  pool  =  new  threadpool(2);for  (int  i  =  1;i  <=  5;i++)  {  pool.assign(new  testworkerthread());}system.out.println(""all  tasks  are  assigned"");pool.complete();system.out.println(""all  tasks  are  done."");  }};  package  hitesh;/**  *  *  @author  jhamb  *//**  *  this  class  shows  an  example  worker  thread  that  can  *  be  used  with  the  thread  pool.  it  demonstrates  the  main  *  points  that  should  be  included  in  any  worker  thread.  use  *  this  as  a  starting  point  for  your  own  threads.  */public  class  testworkerthread  implements  runnable  {  static  private  int  count  =  0;  private  int  tasknumber;  protected  done  done;  /***  *  @param  done*/  testworkerthread()  {count++;tasknumber  =  count;//system.out.println(""tasknumber--->""  +  tasknumber);  }  public  void  run()  {system.out.println(""twt  run  starts  -->""+  this.tostring());for  (int  i=0;i  <=  100;i  +=  25)  {  system.out.println(""task  number:  ""  +  tasknumber  +  ""'  'percent  complete  =  ""  +  i  );  try  {thread.sleep((int)(math.random()*500));  }  catch  (interruptedexception  e)  {  }}system.out.println(""task  for  thread  -->  ""  +  this.tostring()  +  ""  completed"");  }};  package  hitesh;/**  *  *  @author  jhamb  */import  java.util.*;/*  *  this  is  the  main  class  for  the  thread  pool.  you  should  *  create  an  instance  of  this  class  and  assign  tasks  to  it.  */public  class  threadpool  {  protected  thread  threads[]  =  null;  collection  assignments  =  new  arraylist(3);  protected  done  done  =  new  done();  public  threadpool(int  size)  throws  interruptedexception  {  threads  =  new  workerthread[size];  for  (int  i=0;i<threads.length;i++)  {threads[i]  =  new  workerthread(this);threads[i].start();system.out.println  (""thread  ""  +  i  +  ""  started"");threads[i].sleep(1000);}  }  public  synchronized  void  assign(runnable  r)  {done.workerbegin();assignments.add(r);system.out.println(""collection  size  --->  ""  +  assignments.size()  +  ""thread  can  work  on  this"");notify();  }  public  synchronized  runnable  getassignment()  {try  {  while  (  !assignments.iterator().hasnext()  )wait();  runnable  r  =  (runnable)assignments.iterator().next();  assignments.remove(r);  return  r;}  catch  (interruptedexception  e)  {  done.workerend();  return  null;}  }  public  void  complete()  {  done.waitbegin();done.waitdone();  }};  package  hitesh;import  java.util.*;/**  *  *  @author  jhamb  *//**  *  the  worker  threads  that  make  up  the  thread  pool.  */class  workerthread  extends  thread  {  /***  true  if  this  thread  is  currently  processing.*/  public  boolean  busy;  /***  the  thread  pool  that  this  object  belongs  to.*/  public  threadpool  owner;  /***  the  constructor.*  *  @param  o  the  thread  pool  */  workerthread(threadpool  o)  {owner  =  o;  }  /***  scan  for  and  execute  tasks.*///@override  public  void  run()  {system.out.println(""threads  name  :  ""+  this.getname()  +  ""working....."");runnable  target  =  null;do  {  system.out.println(""enter  in  do  while  ""  +  this.getname()  );  target  =  owner.getassignment();  system.out.println(""getassignment  k  aage  aa  gya  mai  ""+target);  if  (target!=null)  {target.run();//target.owner.done.workerend();  }}  while  (target!=null);system.out.println(""do  while  finishes  for  ""+  this.getname());  }};  package  hitesh;/**  *  *  @author  jhamb  *//**  *  *  this  is  a  thread  pool  for  java'  '  it  is  *  simple  to  use  and  gets  the  job  done.  this  program  and  *  all  supporting  files  are  distributed  under  the  limited  *  gnu  public  license  (lgpl'  '  http://www.gnu.org).  *  *  this  is  a  very  simple  object  that  *  allows  the  theadpool  to  determine  when  *  it  is  done.  this  object  implements  *  a  simple  lock  that  the  threadpool  class  *  can  wait  on  to  determine  completion.  *  done  is  defined  as  the  threadpool  having  *  no  more  work  to  complete.  *  *  copyright  2001  by  jeff  heaton  *  *  @author  jeff  heaton  (http://www.jeffheaton.com)  *  @version  1.0  */public  class  done  {  /***  the  number  of  worker  object*  threads  that  are  currently  working*  on  something.*/  private  int  _activethreads  =  0;  /***  this  boolean  keeps  track  of  if*  the  very  first  thread  has  started*  or  not.  this  prevents  this  object*  from  falsely  reporting  that  the  threadpool  *  is  done'  '  just  because  the  first  thread*  has  not  yet  started.*/  private  boolean  _started  =  false;  /***  this  method  can  be  called  to  block*  the  current  thread  until  the  threadpool*  is  done.*/  synchronized  public  void  waitdone()  {try  {  while  (  _activethreads>0  )  {wait();  }}  catch  (  interruptedexception  e  )  {}  }  /***  called  to  wait  for  the  first  thread  to  *  start.  once  this  method  returns  the*  process  has  begun.*/  synchronized  public  void  waitbegin()  {try  {  while  (  !_started  )  {wait();  }}  catch  (  interruptedexception  e  )  {}  }  /***  called  by  a  worker  object*  to  indicate  that  it  has  begun  *  working  on  a  workload.*/  synchronized  public  void  workerbegin()  {_activethreads++;_started  =  true;notify();  }  /***  called  by  a  worker  object  to  *  indicate  that  it  has  completed  a  *  workload.*/  synchronized  public  void  workerend()  {_activethreads--;notify();  }  /***  called  to  reset  this  object  to*  its  initial  state.*/  synchronized  public  void  reset()  {_activethreads  =  0;  }}"  ,after  spend  lot  of  time  with  threadpool  concept  and  by  read  differ  code  on  number  of  blog  and  post  question  on  stackoverflowcom  now  i  got  clear  imag  of  this  concept  but  in  the  meanwhil  i  found  some  doubt  in  code  code  is  as  followsi  am  arrang  the  code  accord  to  it  flow  pleas  help  thank  in  advanc  look  for  your  kind  respons  ,  importstat  ondemandimport  protectedfieldspecifi  instancefield  instancefieldinitializationstat  simpleassignmentexpress  javautilarraylist  objectcreationstat  constructorcal  actualmethodparamet  formalmethodparamet  constructordefinit  publicconstructorspecifi  throwsspecif  intdatatyp  arrayel  objectmethodinvoc  synchronizedmethodspecifi  javautilarraylistadd  javalangsystemoutprintln  stringliter  stringdatatyp  postdecrementexpress  greaterexpress  stringaddit  javautilarraylists  objectvari  simplevari  trycatchstat  whilestat  notexpress  explicittypecast  javautilarraylistremov  returnstat  extendsspecif  publicfieldspecifi  booleandatatyp  multiplyexpress  privatefieldspecifi  fals  postincrementexpress  true 