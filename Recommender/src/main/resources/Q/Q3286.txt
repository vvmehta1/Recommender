 question  ,  "protected  <t>  list<t>  waitforall(list<future<t>>  futures)  throws  multiioexception  {multiioexception  mex  =  null;int  i  =  0;list<t>  result  =  new  arraylist<t>(futures.size());for  (future<t>  f  :  futures)  {try  {result.add(f.get());}  catch  (interruptedexception  ex)  {if  (mex  ==  null)  {mex  =  new  multiioexception();}mex.exceptions.add(new  exceptionpair(metrics[i].file'  '  ex));}  catch  (executionexception  ex)  {if  (mex  ==  null)  {mex  =  new  multiioexception();}mex.exceptions.add(new  exceptionpair(metrics[i].file'  '  ex));}i++;}if  (mex  !=  null)  {throw  mex;}return  result;}public  int  read(long  position'  '  byte[]  output'  '  int  start'  '  int  length)  throws  ioexception  {if  (start  <  0  ||  start  +  length  >  output.length)  {throw  new  indexoutofboundsexception(string.format(""start=%d'  '  length=%d'  '  output=%d""'  '  start'  '  length'  '  output.length));}//  compute  the  fragment  sizes  and  positionsint  result  =  0;final  long[]  positions  =  new  long[metrics.length];final  int[]  lengths  =  new  int[metrics.length];double  speedsum  =  0.0;double  maxvalue  =  0.0;int  maxindex  =  0;for  (int  i  =  0;  i  <  metrics.length;  i++)  {speedsum  +=  metrics[i].readspeed;if  (metrics[i].readspeed  >  maxvalue)  {maxvalue  =  metrics[i].readspeed;maxindex  =  i;}}//  adjust  read  lengthsint  lengthsum  =  length;for  (int  i  =  0;  i  <  metrics.length;  i++)  {int  len  =  (int)math.ceil(length  *  metrics[i].readspeed  /  speedsum);lengths[i]  =  (len  >  lengthsum)  ?  lengthsum  :  len;lengthsum  -=  lengths[i];}if  (lengthsum  >  0)  {lengths[maxindex]  +=  lengthsum;}//  adjust  read  positionslong  positiondelta  =  position;for  (int  i  =  0;  i  <  metrics.length;  i++)  {positions[i]  =  positiondelta;positiondelta  +=  (long)lengths[i];  }list<future<byte[]>>  futures  =  new  linkedlist<future<byte[]>>();//  read  in  parallelfor  (int  i  =  0;  i  <  metrics.length;  i++)  {final  int  j  =  i;futures.add(exec.submit(new  callable<byte[]>()  {@overridepublic  byte[]  call()  throws  exception  {byte[]  buffer  =  new  byte[lengths[j]];long  t  =  system.nanotime();long  t0  =  t;long  currpos  =  metrics[j].handle.getfilepointer();metrics[j].handle.seek(positions[j]);t  =  system.nanotime()  -  t;metrics[j].seektime  =  t  *  1024.0  *  1024.0  /  math.abs(currpos  -  positions[j])  /  1e9  ;int  c  =  metrics[j].handle.read(buffer);t0  =  system.nanotime()  -  t0;//  adjust  the  read  speed  if  we  read  somethingif  (c  >  0)  {metrics[j].readspeed  =  (alpha  *  c  *  1e9  /  t0  /  1024  /  1024+  (1  -  alpha)  *  metrics[j].readspeed)  ;}if  (c  <  0)  {return  null;}  elseif  (c  ==  0)  {return  empty_byte_array;}  elseif  (c  <  buffer.length)  {return  arrays.copyof(buffer'  '  c);}return  buffer;}}));}list<byte[]>  data  =  waitforall(futures);boolean  eof  =  true;for  (byte[]  b  :  data)  {if  (b  !=  null  &&  b.length  >  0)  {system.arraycopy(b'  '  0'  '  output'  '  start  +  result'  '  b.length);result  +=  b.length;eof  =  false;}  else  {break;  //  the  rest  probably  reached  eof}}//  if  there  was  no  data  at  all'  '  we  reached  the  end  of  fileif  (eof)  {return  -1;}sequentialposition  =  position  +  (long)result;//  evaluate  the  fastest  file  to  readdouble  maxspeed  =  0;maxindex  =  0;for  (int  i  =  0;  i  <  metrics.length;  i++)  {if  (metrics[i].readspeed  >  maxspeed)  {maxspeed  =  metrics[i].readspeed;maxindex  =  i;}}fastest  =  metrics[maxindex];return  result;}"  ,i  have  implement  a  small  io  class  which  can  read  from  multipl  and  same  file  on  differ  disk  eg  two  hard  disk  contain  the  same  file  in  sequenti  case  both  disk  read  mbs  in  averag  over  the  file  but  when  i  do  an  interleav  eg  k  disk  k  disk  then  combin  the  effect  read  speed  is  reduc  to  mbs  instead  of  increasingcontext  win  jdk  b  gb  ram  gb  test  file  basic  i  tri  to  mimic  win  readyboost  and  raid  x  in  a  poor  man  fashion  in  the  heart  when  a  read  is  issu  to  the  class  it  creat  two  runnabl  with  instruct  to  read  a  preopen  randomaccessfil  from  a  certain  posit  and  length  use  an  executor  servic  and  futureget  call  when  both  finish  the  data  read  get  copi  into  a  common  buffer  and  return  to  the  caller  is  there  a  concept  error  in  my  approach  for  exampl  the  os  cach  mechan  will  alway  counteract  filemetr  in  metric  array  contain  measur  of  read  speed  to  adapt  determin  the  buffer  size  of  various  input  channel  in  my  test  with  alpha  and  readspe  result  equal  distribut  i  ran  an  nonentangl  test  eg  read  the  two  file  independ  in  separ  thread  and  ive  got  a  combin  effect  speed  of  mbs  i  guess  i  know  whi  is  this  happen  when  i  read  in  parallel  and  in  sequenc  it  is  not  a  sequenti  read  for  the  disk  but  rather  readskipreadskip  pattern  due  the  interleav  and  possibl  riddl  with  alloc  tabl  lookup  this  basic  reduc  the  effect  read  speed  per  disk  to  half  or  wors  ,  instancefield  simplevari  ifstat  equalexpress  null  simpleassignmentexpress  objectcreationstat  constructorcal  objectmethodinvoc  actualmethodparamet  instancefieldinvoc  arrayel  formalmethodparamet  intdatatyp  longdatatyp  arraydatatyp  bytedatatyp  javalangstringlength  instancefieldinitializationstat  booleandatatyp  true  notequalexpress  andexpress  arraylength  greaterexpress  addassignmentexpress  fals          