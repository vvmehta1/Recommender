 question  ,  "import  java.awt.component;import  java.awt.eventqueue;import  java.awt.font;import  java.awt.datatransfer.stringselection;import  java.awt.datatransfer.transferable;import  java.beans.propertychangeevent;import  java.beans.propertychangelistener;import  javax.swing.dropmode;import  javax.swing.jcomponent;import  javax.swing.jframe;import  javax.swing.jlabel;import  javax.swing.jscrollpane;import  javax.swing.jtable;import  javax.swing.jviewport;import  javax.swing.transferhandler;import  javax.swing.uimanager;import  javax.swing.event.changeevent;import  javax.swing.event.changelistener;import  javax.swing.table.defaulttablecellrenderer;import  javax.swing.table.jtableheader;import  javax.swing.table.tablecolumn;public  class  dndlinepainterexamplemain  extends  jframe  {public  dndlinepainterexamplemain()  {jtable  maintable  =  new  jtable(4'  '  3);maintable.setautoresizemode(jtable.auto_resize_off);jtable  rowtable  =  new  rowheadertable(maintable);rowtable.setautoscrolls(true);rowtable.setdragenabled(true);rowtable.settransferhandler(new  rowheadertransferhandler());rowtable.setdropmode(dropmode.insert_rows);jscrollpane  scrollpane  =  new  jscrollpane(maintable);scrollpane.setrowheaderview(rowtable);scrollpane.setcorner(jscrollpane.upper_left_corner'  'rowtable.gettableheader());this.add(scrollpane);}public  static  void  main(string[]  args)  {eventqueue.invokelater(new  runnable()  {@overridepublic  void  run()  {jframe  f  =  new  dndlinepainterexamplemain();f.setdefaultcloseoperation(jframe.exit_on_close);f.pack();f.setvisible(true);}});}/*  *  use  a  jtable  as  a  renderer  for  row  numbers  of  a  given  main  table.  this  *  table  must  be  added  to  the  row  header  of  the  scrollpane  that  contains  the  *  main  table.  from:  *  http://tips4java.wordpress.com/2008/11/18/row-number-table/  */public  class  rowheadertable  extends  jtable  implements  changelistener'  'propertychangelistener  {private  final  jtable  table;public  rowheadertable(jtable  table)  {this.table  =  table;table.addpropertychangelistener(this);setfocusable(false);setautocreatecolumnsfrommodel(false);updaterowheight();updatemodel();updateselectionmodel();tablecolumn  column  =  new  tablecolumn();column.setheadervalue("""");addcolumn(column);column.setcellrenderer(new  rownumberrenderer());getcolumnmodel().getcolumn(0).setpreferredwidth(50);setpreferredscrollableviewportsize(getpreferredsize());gettableheader().setreorderingallowed(false);}@overridepublic  void  addnotify()  {super.addnotify();component  c  =  getparent();//  keep  scrolling  of  the  row  table  in  sync  with  the  main  table.if  (c  instanceof  jviewport)  {jviewport  viewport  =  (jviewport)  c;viewport.addchangelistener(this);}}/*  *  delegate  method  to  main  table  */@overridepublic  int  getrowcount()  {return  table.getrowcount();}@overridepublic  int  getrowheight(int  row)  {return  table.getrowheight(row);}/*  *  this  table  does  not  use  any  data  from  the  main  tablemodel'  '  so  just  return  *  a  value  based  on  the  row  parameter.  */@overridepublic  object  getvalueat(int  row'  '  int  column)  {return  integer.tostring(row  +  1);}/*  *  don't  edit  data  in  the  main  tablemodel  by  mistake  */@overridepublic  boolean  iscelleditable(int  row'  '  int  column)  {return  false;}//  implements  changelistener@overridepublic  void  statechanged(changeevent  e)  {//  keep  the  scrolling  of  the  row  table  in  sync  with  main  tablejviewport  viewport  =  (jviewport)  e.getsource();jscrollpane  scrollpane  =  (jscrollpane)  viewport.getparent();scrollpane.getverticalscrollbar().setvalue(viewport.getviewposition().y);}//  implements  propertychangelistener@overridepublic  void  propertychange(propertychangeevent  e)  {//  keep  the  row  table  in  sync  with  the  main  tableif  (""rowheight"".equals(e.getpropertyname()))updaterowheight();if  (""selectionmodel"".equals(e.getpropertyname()))updateselectionmodel();if  (""model"".equals(e.getpropertyname()))updatemodel();}private  void  updaterowheight()  {setrowheight(table.getrowheight());}private  void  updatemodel()  {setmodel(table.getmodel());}private  void  updateselectionmodel()  {setselectionmodel(table.getselectionmodel());}/*  *  borrow  the  renderer  from  jdk1.4.2  table  header  */private  class  rownumberrenderer  extends  defaulttablecellrenderer  {public  rownumberrenderer()  {sethorizontalalignment(jlabel.center);}@overridepublic  component  gettablecellrenderercomponent(jtable  table'  'object  value'  '  boolean  isselected'  '  boolean  hasfocus'  '  int  row'  'int  column)  {if  (table  !=  null)  {jtableheader  header  =  table.gettableheader();if  (header  !=  null)  {setforeground(header.getforeground());setbackground(header.getbackground());setfont(header.getfont());}}if  (isselected)  {setfont(getfont().derivefont(font.bold));}settext((value  ==  null)  ?  """"  :  value.tostring());setborder(uimanager.getborder(""tableheader.cellborder""));return  this;}}//class  rownumberrenderer}//class  rowheadertablepublic  class  rowheadertransferhandler  extends  transferhandler  {@overridepublic  int  getsourceactions(jcomponent  c)  {return  copy_or_move;}@overrideprotected  transferable  createtransferable(jcomponent  c)  {return  new  stringselection(c.getname());}@overridepublic  boolean  canimport(transfersupport  supp)  {return  true;}}//class  rowheadertransferhandler}//class  dndlinepainterexamplemain"  ,im  use  a  second  jtabl  in  the  viewport  of  a  jscrollpan  to  build  a  rowhead  for  a  main  tabledraganddrop  on  the  main  tabl  is  disabl  on  the  rowhead  tabl  dnd  is  enabledif  a  drag  on  the  rowhead  is  start  by  the  user  i  want  to  extend  the  paint  rowhead  droplin  the  black  line  in  the  imag  over  the  main  tabl  like  the  green  line  in  the  imag  doe  anybodi  have  an  advic  for  me  here  the  sscce  ,  objectmethodinvoc  actualmethodparamet  simpleassignmentexpress  objectcreationstat  constructorcal  true  extendsspecif  implementsspecif  methodimplement  privatefieldspecifi  finalfieldspecifi  instancefield  simplevari  formalmethodparamet  instancefieldinvoc  thisrefer  fals  stringliter  stringdatatyp  intdatatyp  javalangobject  objectvari  booleandatatyp  ifstat  notequalexpress  null  equalexpress  returnstat    objectvari  simplevari  privatemethodspecifi  simpleassignmentexpress  objectmethodinvoc     objectmethodinvoc  actualmethodparamet  constant  constantinitializationstat  simpleassignmentexpress  objectcreationstat  constructorcal  true  intdatatyp  forstat  lessexpress  postincrementexpress  addexpress  instancefield  instancefieldinitializationstat  explicittypecast  extendsspecif  implementsspecif  methodimplement  privatefieldspecifi  finalfieldspecifi  simplevari  formalmethodparamet  instancefieldinvoc  thisrefer  fals  stringliter  stringdatatyp  objectvari  returnstat  javalangobject  booleandatatyp  ifstat  notequalexpress  null  equalexpress     objectcreationstat  constructorcal  actualmethodparamet  simpleassignmentexpress  objectmethodinvoc  ifstat  notequalexpress  null  privatefieldspecifi  finalfieldspecifi  instancefield  simplevari  formalmethodparamet  instancefieldinvoc  thisrefer  fals  stringliter  stringdatatyp  equalexpress  returnstat  constant  constantinitializationstat  intdatatyp  lessexpress  subtractexpress  divideexpress  constantinvoc  objectvari  multiplyexpress  javalangobject  booleandatatyp  